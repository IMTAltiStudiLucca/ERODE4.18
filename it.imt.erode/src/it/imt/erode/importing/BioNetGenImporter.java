package it.imt.erode.importing;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.StringTokenizer;

import org.eclipse.ui.console.MessageConsoleStream;

import it.imt.erode.commandline.CRNReducerCommandLine;
import it.imt.erode.commandline.IMessageDialogShower;
import it.imt.erode.crn.implementations.CRNMassActionReactionCompact;
import it.imt.erode.crn.implementations.CRNReaction;
import it.imt.erode.crn.implementations.Composite;
import it.imt.erode.crn.implementations.Species;
import it.imt.erode.crn.implementations.SpeciesCompact;
import it.imt.erode.crn.interfaces.ICRN;
import it.imt.erode.crn.interfaces.ICRNReaction;
import it.imt.erode.crn.interfaces.IComposite;
import it.imt.erode.crn.interfaces.ISpecies;
import it.imt.erode.partition.implementations.Block;
import it.imt.erode.partition.implementations.Partition;
import it.imt.erode.partition.interfaces.IBlock;
import it.imt.erode.partition.interfaces.IPartition;


/**
 * 
 * @author Andrea Vandin
 * This class is used to import reaction networks generated by the BioNetGen2.2.5-stable tool (file extension: .net).
 * At the end of the class we have a sample input file.
 */
public class BioNetGenImporter extends AbstractImporter{

 	public static final String BNGNetworksFolder = "."+File.separator+"BNGNetworks"+File.separator;
	private static final BigDecimal MinusOne = BigDecimal.valueOf(-1);
	private boolean lowMemoryFootprint=true;

	public BioNetGenImporter(String fileName,MessageConsoleStream out,BufferedWriter bwOut,IMessageDialogShower msgDialogShower, boolean lowMemory) {
		super(fileName,out,bwOut,msgDialogShower);
		this.lowMemoryFootprint=lowMemory;
	}
	
	private static String toBNGGroup(IBlock block,HashMap<ISpecies, Integer> speciesToIdInNetFile){
		StringBuilder sb=new StringBuilder(block.getRepresentative(CRNReducerCommandLine.COMPUTEREPRESENTATIVEBYMINOUTSIDEPARTITIONREFINEMENT).getName().replace("~", "").replace(",", ""));
		//StringBuilder sb=new StringBuilder(getRepresentative().getName() + " "+ getRepresentative().getName().replace("~", "").replace(",", ""));
		sb.append(" ");
		
		for (ISpecies species : block.getSpecies()) {
			//sb.append((species.getID()+speciesIdIncrement));
			sb.append(speciesToIdInNetFile.get(species));
			sb.append(",");
		}
		String ret = sb.toString();
		if(ret.endsWith(",")){
			ret = ret.substring(0, ret.length()-1);
		}
		
		return ret;
	}
	
	/**
	 * 
	 * @param br
	 * @param infoImporting 
	 * @return 
	 * @throws IOException
	 * Assumnptions: the expression defining the value of a function contains only parameters or functions defined in the previous lines of the file.
	 * I accept only constant functions, e.g. "Fkm() 0.1/A", with "A" being a parameter.
	 * We essentially transform each constant function in a parameter 
	 */
	protected boolean loadConstantFunctions(BufferedReader br, boolean parametersHaveId) throws IOException {
		String line = br.readLine();

		while ((line != null) && (!(line=line.trim()).startsWith("end functions"))) {
			//Skip comments or empty lines
			if(!(line.equals("") || line.startsWith("#"))){
				line=removeCommentAtTheEnd(line,'#');
				if(parametersHaveId){
					line = line.substring(line.indexOf(" ")+1, line.length());
				}
				
				int posOfSpace = line.indexOf(" ");
				String functionName = line.substring(0, posOfSpace);
				if(functionName.endsWith(")") && ! functionName.endsWith("()")){
					//throw new IOException("Only constant functions are supported: "+line);
					CRNReducerCommandLine.println(out,bwOut,"Only constant functions are supported: "+line);
					return false;
				}
				else{
					functionName=functionName.substring(0, functionName.length()-2);
				}
				
				String functionExpression = line.substring(posOfSpace+1, line.length());
				//We now transform all constant function invocations in parameters.
				//functionExpression = functionExpression.replace("()", "");
				
				//getCRN().addParameter(functionName,functionExpression);
				AbstractImporter.addParameter(functionName, functionExpression, true, getCRN());

				double functionValue=-1;
				try  
				{  
					functionValue = Double.valueOf(functionExpression);  
				}  
				catch(NumberFormatException nfe)  
				{  
					try{
					functionValue = getMath().evaluate(functionExpression);
					}
					catch(Exception e){
						CRNReducerCommandLine.printStackTrace(out,bwOut,e);
						return false;
					}
				}  			
				getMath().setVariable(functionName, functionValue);
			}
			line = br.readLine();
		}
		getInfoImporting().setReadParameters(getCRN().getParameters().size());
		return true;
	}
	
	public InfoCRNImporting importBioNetGenNetwork(boolean printInfo, boolean printCRN,boolean print,boolean compactNames, boolean writeFileWithSpeciesNameCorrespondences) throws FileNotFoundException, IOException{

		if(print){
			CRNReducerCommandLine.println(out,bwOut,"\nImporting: "+getFileName());
		}
		
		initInfoImporting();
		initCRNAndMath();
		ICRN crn = getCRN();
		getInfoImporting().setLoadedCRN(true);
		
		/*//dummy species used to let the id of a species coincide with its position in the list
		crn.addSpecies(Species.ZEROSPECIES);
		//the initial partition: one block for 0 and one block for all the other species
		IBlock zeroBlock = new Block();
		zeroBlock.addSpecies(Species.ZEROSPECIES);
		IBlock uniqueBlock = new Block();
		setInitialPartition(new Partition(zeroBlock, uniqueBlock));*/
		//IBlock uniqueBlock = new Block();
		//setInitialPartition(new Partition(uniqueBlock));
		
		BufferedReader br = getBufferedReader();
		String line;
		//I assume that first the parameters are generated, then the species, and finally the reactions. In this way I reduce the string comparisons
		boolean parametersGenerated = false;
		boolean functionsGenerated = false;
		boolean speciesGenerated = false;
		boolean viewsLoaded=false;
		boolean reactionsLoaded=false;
		//boolean ok=true;
		
		//ISpecies[] allSpecies=null;
		
		//HashMap<ISpecies, String> speciesToLongName = new HashMap<>();
		long begin = System.currentTimeMillis();
		while ((line = br.readLine()) != null) {
			line=line.trim();

			//parameters are optional. If there are some, they must appear before the species
			if((!parametersGenerated) && (!speciesGenerated) && line.startsWith("begin parameters")){
				loadParameters(br,true,false);
				parametersGenerated = true;
			}
			//functions are optional. If there are some, they must appear before the species. I accept only constant functions, e.g. "Fkm() 0.1/A", with "A" being a parameter
			else if((!functionsGenerated) && (!speciesGenerated) && line.startsWith("begin functions")){
				throw new UnsupportedOperationException("BNG functions are not supported.");
				//In a previous version we tried to support functions
				/*ok=loadConstantFunctions(br,true);
				if(!ok){
					getInfoImporting().setLoadingCRNFailed();
					return getInfoImporting();
				}
				functionsGenerated = true;*/
			}
			
			//else if(parametersGenerated && (!speciesGenerated) && line.startsWith("begin species")){
			else if( (!speciesGenerated) && line.startsWith("begin species")){
				//allSpecies = 
				loadSpecies(br,compactNames/*,speciesToLongName*/,writeFileWithSpeciesNameCorrespondences);
				speciesGenerated = true;
			}
			else if(speciesGenerated && (!reactionsLoaded) && line.startsWith("begin reactions")){
				/*int n_ary =*/loadReactions(br/*,allSpecies*/);
				//CRNReducerCommandLine.print(out,bwOut," ("+n_ary +" n_ary reactions) ");
				IBlock uniqueBlock = new Block();
				setInitialPartition(new Partition(uniqueBlock,getCRN().getSpecies().size()));
				for (ISpecies species : getCRN().getSpecies()) {
					uniqueBlock.addSpecies(species);
				}
				reactionsLoaded=true;
			}
			else if(reactionsLoaded && (!viewsLoaded) && line.startsWith("begin groups")){
				//The views must be specified after the reactions
				loadViews(br/*,allSpecies*/,compactNames);
				viewsLoaded=true;
			}
			//Any other line is ignored (including comments)
			else if(line.startsWith("#")){
				//if this is a comment line, skip to the next iteration of the loop (i.e. to the next line)
				continue;
			}
		}
		setRequiredMS(System.currentTimeMillis()-begin);
		br.close();
		
		//CRNReducerCommandLine.println(out,bwOut,"BioNetGenImporter.importBioNetGenNetwork: completed importing of model "+fileName);
		if(print){
			if(printInfo){
				CRNReducerCommandLine.println(out,bwOut,getInfoImporting().toString());
			}
			if(printCRN){
				crn.printCRN();
			}
		}
		
		/*if(getCRN().getViewNames().length==0){
			Set<ISpecies> speciesOfDefaultView = new LinkedHashSet<ISpecies>(getCRN().getSpecies());
			ArrayList<Set<ISpecies>> defaultView = new ArrayList<Set<ISpecies>>(1);
			defaultView.add(speciesOfDefaultView);
			getCRN().setViewsForPrepartioning(defaultView);
		}*/
		
		/*if(crn!=null){
			checkACTMC();
		}*/
		
		
		/*
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////BEGIN ATOMIC CTMC////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		boolean allAtomicCTMCsDerivable=true;
		//Build the set of monomers
		LinkedHashSet<String> monomers = new LinkedHashSet<String>();
		for (ISpecies species : crn.getSpecies()) {
			String[] monomersArray = species.getName().replace(" ","").split("\\.");
			for(int m=0;m<monomersArray.length;m++){
				if(monomersArray[m].isEmpty()){
					continue;
				}
				else{
					int posPar = monomersArray[m].indexOf('(');
					if(posPar==-1){
						if(monomersArray[m].equals(Species.ZEROSPECIESNAME)){
							monomers.add(Species.ZEROSPECIESNAME);
						}
						else{
							allAtomicCTMCsDerivable=false;
							CRNReducerCommandLine.println(out,bwOut,crn.getName()+": It is not possible to derive the atomic CTMC because its species are not monomers-based");
							break;
						}
					}
					else{
						monomers.add(monomersArray[m].substring(0, posPar));
					}
				}
			}
			if(!allAtomicCTMCsDerivable){
				break;
			}
		}
	
		if(allAtomicCTMCsDerivable){
			CRNReducerCommandLine.println(out,bwOut,"We have "+monomers.size()+" monomers. These are monomers for which it is not possible to generate the atomic CTMC.");
			LinkedHashSet<String> unsupportedMonomers = new LinkedHashSet<String>();
			MutableInteger counterUnsupportedMonomers=new MutableInteger(0);			
			for (String mon : monomers) {
				if(!crn.isAtomicCTMCDerivable(mon,counterUnsupportedMonomers)){
					allAtomicCTMCsDerivable=false;
					unsupportedMonomers.add(mon);
					//CRNReducerCommandLine.println(out,bwOut,crn.getName()+": It is not possible to derive the atomic CTMC for the monomer "+mon);
					//break;
				}
			}
		}
		if(allAtomicCTMCsDerivable){
			CRNReducerCommandLine.println(out,bwOut,"It is possible to derive the atomic CTMC for all monomers.");
		}
		//else {
		//	CRNReducerCommandLine.println(out,bwOut,crn.getName()+": It not is possible to derive the atomic CTMC for some monomer.");
		//}
		
		CRNReducerCommandLine.println(out,bwOut,"");
		CRNReducerCommandLine.println(out,bwOut,"");
		CRNReducerCommandLine.println(out,bwOut,"");
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////END ATOMIC CTMC////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		*/
		
		return getInfoImporting();
	}

	
	/**
	 * It is assumed that the reactions have been already read (and thus the species have been created)
	 * @param br the buffered reader from which to read
	 * @param speciesNameToSpecies an hash map from species name to species
	 * @throws IOException 
	 */
	private void loadViews(BufferedReader br, /*ISpecies[] allSpecies,*/boolean compactNames/*,HashMap<ISpecies,String> speciesToLongName*/) throws IOException {
		
		String line = br.readLine();
		List<String> viewNames = new ArrayList<String>();
		List<String> viewExpressions = new ArrayList<String>();
		List<String> viewExpressionsSupportedByMathEval = new ArrayList<String>();
		List<HashMap<ISpecies,Integer>> setsOfSpeciesOfViews = new ArrayList<HashMap<ISpecies,Integer>>();
		boolean viewsSupportedForPrepartitioning=true;
		while ((line != null) && (!(line=line.trim()).startsWith("end groups"))) {
			//Skip comments or empty lines
			if(!(line.equals("") || line.startsWith("#"))){

				line = removeCommentAtTheEnd(line,'#');

				//throw away the id of the view
				line = line.substring(line.indexOf(' ')).trim();
				//Read the view  "viewName comma separated list of species"
				int posFirstSpaceAfterViewName = line.indexOf(' ');
				if(posFirstSpaceAfterViewName==-1){
					CRNReducerCommandLine.printWarning(out,bwOut,"Problems in loading the view "+line);
				}
				else{
					String viewName = line.substring(0,posFirstSpaceAfterViewName);
					viewNames.add(viewName);
					String group = line.substring(posFirstSpaceAfterViewName+1, line.length()).trim();
					viewExpressions.add(fromGroupToView(group,1,false,/*allSpecies,*/compactNames));
					viewExpressionsSupportedByMathEval.add(fromGroupToView(group,1,true,/*allSpecies,*/compactNames));

					if(viewsSupportedForPrepartitioning){
						HashMap<ISpecies, Integer> setsOfSpeciesOfView = setOfSpeciesInCaseIsABlockWithMultiplicities(group, 1/*,allSpecies*/);
						if(setsOfSpeciesOfView==null){
							viewsSupportedForPrepartitioning=false;
							setsOfSpeciesOfViews=null;
						}
						else{
							setsOfSpeciesOfViews.add(setsOfSpeciesOfView);
						}
					}
				}
			}
			line = br.readLine();
		}
		String[] viewNamesArray = new String[viewNames.size()];
		String[] viewExpressionsArray = new String[viewNames.size()];
		String[] viewExpressionsSupportedByMathEvalArray = new String[viewNames.size()];
		boolean[] useCovariances = new boolean[viewNames.size()];//Array init to false
		getCRN().setViews(viewNames.toArray(viewNamesArray), viewExpressions.toArray(viewExpressionsArray),viewExpressionsSupportedByMathEval.toArray(viewExpressionsSupportedByMathEvalArray),useCovariances);
		
		if(viewsSupportedForPrepartitioning){
			getCRN().setViewsAsMultiset(setsOfSpeciesOfViews);
			getCRN().setUserDefinedPartition(viewsAsMultisetsToUserPartition(setsOfSpeciesOfViews,getCRN()));
		}
		
	}
	
	

	/*private LinkedHashSet<ISpecies> setOfSpeciesInCaseIsABlock(String group, int decrement){

		LinkedHashSet<ISpecies> speciesOfTheGroup = new LinkedHashSet<ISpecies>();
		String[] addends=group.split(",");
		for(int i=0;i<addends.length;i++){
			String addend = addends[i].trim();
			//Views made of arithmetical expressions are not supported
			if(!addend.equals("")){
				if(addend.contains("*")||addend.contains("/")||addend.contains("-")||addend.contains("+")){//The "+" could actually be treated. 
					return null;
				}
				else{
					boolean added=speciesOfTheGroup.add(getCRN().getSpecies().get(Integer.valueOf(addend)-decrement));
					//Views where a species appears more than once are not supported  
					if(!added){
						return null;
					}
				}
			}
		}
		return speciesOfTheGroup;
	}*/
	
	private LinkedHashMap<ISpecies,Integer> setOfSpeciesInCaseIsABlockWithMultiplicities(String group, int decrement/*, ISpecies[] allSpecies*/){

		LinkedHashMap<ISpecies,Integer> speciesOfTheGroup = new LinkedHashMap<ISpecies,Integer>();
		String[] addends=group.split(",");
		for(int i=0;i<addends.length;i++){
			String addend = addends[i].trim();
			if(!addend.equals("")){
				//Case 1: Views made of general arithmetical expressions are not supported. We accept only "speciesID" or "multiplicity*speciesID" (e.g., 2*4). We also accept the case in which a species appears more than once.
				if(addend.contains("/")||addend.contains("-")||addend.contains("+")){//The "+" could actually be treated. 
					return null;
				}
				//Case 2: multiplicity*speciesID (e.g., 2*4)
				else if(addend.contains("*")){ 
					String[] factors=addend.split("\\*");
					if(factors.length!=2){
						return null;
					}
					else{
						int mult = Integer.valueOf(factors[0]);
						ISpecies species = getCRN().getSpecies().get(Integer.valueOf(factors[1])-decrement);
						Integer prevMultiplicity = speciesOfTheGroup.get(species);
						if(prevMultiplicity==null){
							speciesOfTheGroup.put(species,mult);
						}
						else{
							speciesOfTheGroup.put(species,mult + prevMultiplicity);
						}
					}
				}
				//Case 3: just a simple speciesID
				else{
					ISpecies species = getCRN().getSpecies().get(Integer.valueOf(addend)-decrement);
					Integer prevMultiplicity = speciesOfTheGroup.get(species);
					if(prevMultiplicity==null){
						speciesOfTheGroup.put(species,1);
					}
					else{
						speciesOfTheGroup.put(species,1 + prevMultiplicity);
					}
				}
			}
		}
		return speciesOfTheGroup;
	}
	
	private String fromGroupToView(String group, int decrement, boolean supportedByMathEval/*, ISpecies[] allSpecies*/,boolean compactNames){
		String expression;
		/*//I first replace "," with "+"
		expression = group.replace(',', '+');
		//Then I just replace all ids with the names of the species
		for(int s=getCRN().getSpecies().size();s>0;s--){
			String name;
			if(supportedByMathEval){
				name = getCRN().getSpecies().get(Integer.valueOf(s)-decrement).getNameSupportedByMathEval();
			}
			else{
				name = getCRN().getSpecies().get(Integer.valueOf(s)-decrement).getName();
			}
			expression=expression.replace(String.valueOf(s), name);
		}*/
		
		StringBuilder sb = new StringBuilder();
		String[] addends=group.split(",");
		
		//I manipulate the expression to change the id in the name of the species, and (if required) removing characters not supported by MathEval
		for(int i=0;i<addends.length;i++){
			String addend = addends[i].trim();
			if(!addend.equals("")){
				visitExpr(sb,addend,decrement,supportedByMathEval,getCRN().getSpecies());
				//sb.append(getCRN().getSpecies().get(Integer.valueOf(addend)-decrement));
				if(i!=addends.length-1){
					sb.append('+');
				}
			}
		}
		/*if(sb.length()>0){
			sb.deleteCharAt(sb.length()-1);
		}*/
		expression = sb.toString();
		
		
		/*if(supportedByMathEval){
			StringBuilder sb = new StringBuilder();
			String[] addends=group.split(",");
			//I manipulate the expression to remove characters not supported by MathEval
			for(int i=0;i<addends.length;i++){
				String addend = addends[i].trim();
				if(!addend.equals("")){
					visitExpr(sb,addend,decrement);
					//sb.append(getCRN().getSpecies().get(Integer.valueOf(addend)-decrement));
					sb.append('+');
				}
			}
			if(sb.length()>0){
				sb.deleteCharAt(sb.length()-1);
			}
			expression = sb.toString();
		}
		else{
			//I just replace "," with "+"
			expression = group.replace(',', '+');
			//I just replace all ids with the names of the species
			for(int s=getCRN().getSpecies().size()-1;s>=0;s--){
				expression=expression.replace(String.valueOf(s), getCRN().getSpecies().get(Integer.valueOf(s)-decrement).getName());
			}
		}*/
		
		return expression;
	}
	
	/**
	 * Visits a string representing a view. E.g., 1,8,2*9 means: s0+s7+2*s8
	 * @param sb
	 * @param addend
	 * @param decrement
	 * @param supportedByMathEval
	 * @param allSpecies
	 */
	private void visitExpr(StringBuilder sb, String addend, int decrement, boolean supportedByMathEval, List<ISpecies> allSpecies) {
		if(addend.contains("*")){
			String[] nodes = addend.split("\\*");
			//2*9 means 2*s8
			String multiplier=nodes[0].trim();
			sb.append(multiplier);
			sb.append('*');
			for(int i=1;i<nodes.length;i++){
				String node=nodes[i].trim();
				visitExpr(sb, node, decrement,supportedByMathEval,allSpecies);
				if(i!=nodes.length-1){
					sb.append('*');
				}
			}
		}
		else if(addend.contains("/")){
			String[] nodes = addend.split("/");
			for(int i=0;i<nodes.length;i++){
				String node=nodes[i].trim();
				visitExpr(sb, node, decrement,supportedByMathEval,allSpecies);
				if(i!=nodes.length-1){
					sb.append('/');
				}
			}
		}
		else if(addend.contains("+")){
			String[] nodes = addend.split("\\+");
			for(int i=0;i<nodes.length;i++){
				String node=nodes[i].trim();
				visitExpr(sb, node, decrement,supportedByMathEval,allSpecies);
				if(i!=nodes.length-1){
					sb.append('+');
				}
			}
		}
		else if(addend.contains("-")){
			String[] nodes = addend.split("\\-");
			for(int i=0;i<nodes.length;i++){
				String node=nodes[i].trim();
				visitExpr(sb, node, decrement, supportedByMathEval,allSpecies);
				if(i!=nodes.length-1){
					sb.append('-');
				}
			}
		}
		else{
			//Then I assume that this the id of a species (add other cases if necessary)
			if(supportedByMathEval){
				//sb.append(getCRN().getSpecies().get(Integer.valueOf(addend)-decrement).getNameSupportedByMathEval());
				sb.append(allSpecies.get(Integer.valueOf(addend)-decrement).getNameAlphanumeric());
			}
			else{
				//sb.append(getCRN().getSpecies().get(Integer.valueOf(addend)-decrement).getName());
				sb.append(allSpecies.get(Integer.valueOf(addend)-decrement).getName());
			}
		}

	}


	/**
	 * 
	 * @param sumViewExpr a view expression. It is assumed that it only contains sums of species
	 * @param speciesToIdInNetFile 
	 * @return the BNG group corresponding to the view
	 */
	private static String fromSumViewToGroup(ICRN crn, String viewName, String sumViewExpr, /*HashMap<ISpecies, Integer> speciesToIdInNetFile,*/HashMap<String, Integer> speciesNameToIdInNetFile,MessageConsoleStream out, Collection<String> skippedViews){

		/*HashMap<String, Integer> speciesNameToId = new HashMap<String, Integer>(crn.getSpecies().size());
		for (ISpecies species : crn.getSpecies()) {
			speciesNameToId.put(species.getName(), species.getID());
		}*/

		StringBuilder sb = new StringBuilder();
		String[] addends=null;
		try{
			addends=sumViewExpr.split("\\+");
		} catch (java.util.regex.PatternSyntaxException e) {
			//CRNReducerCommandLine.println(out,bwOut,"I hade problems while converting the view " +viewName + " " +sumViewExpr+" as a BNG group. I will skip this group/view.");
			skippedViews.add(viewName);
			return "";
		}
		for(int i=0;i<addends.length;i++){
			String addend = addends[i].trim();
			if(!addend.equals("")){
				Integer speciesId = speciesNameToIdInNetFile.get(addend);
				//Integer speciesId = speciesToIdInNetFile.get(addend);
				if(speciesId==null){
					//CRNReducerCommandLine.println(out,bwOut,"The view " +viewName + " " +sumViewExpr+" cannot be encoded as a BNG group. I will skip this group/view.");
					//CRNReducerCommandLine.println(out,bwOut,"The view " +viewName +" will be skept.");
					skippedViews.add(viewName);
					return "";
				}
				else{
					sb.append(speciesId);
					sb.append(',');
				}

			}
		}
		if(sb.length()>0){
			sb.deleteCharAt(sb.length()-1);
		}
		return sb.toString();
	}

	/**
	 * 
	 * @param br
	 * @param math
	 * @param crn
	 * @param uniqueBlock
	 * @param infoImporting
	 * @throws IOException
	 * It is assumed that the id of a species corresponds to the order with which it has been inserted: the i_th inserted species has id "i". 
	 * Also, we start counting from 0 rather than from 1, and thus we decrease by one the ids of all species.
	 */
	private /*ISpecies[]*/ void loadSpecies(BufferedReader br,boolean compactNames, /*HashMap<ISpecies, String> speciesToLongName,*/boolean writeFileWithSpeciesNameCorrespondences) throws IOException {
		BufferedWriter bwSpeciesNames = null;
		if(compactNames && writeFileWithSpeciesNameCorrespondences){
			String fileNameSpeciesNames =overwriteExtensionIfEnabled(getFileName(),"",true);
			fileNameSpeciesNames=fileNameSpeciesNames+"Names.txt";
			bwSpeciesNames=new BufferedWriter(new FileWriter(fileNameSpeciesNames));
			bwSpeciesNames.write("Correspondence between the short and original species names from:\n\t"+getFileName()+"\n\n");
		}

		String line = br.readLine();
		//dummy species used to let the id of a species coincide with its position in the list
		//crn.addSpecies(Species.ZEROSPECIES);
		//uniqueBlock.addSpecies(Species.ZEROSPECIES);
		while ((line != null) && (!(line=line.trim()).startsWith("end species"))) {
			//Skip comments or empty lines
			if(!(line.equals("") || line.startsWith("#"))){
				line=removeCommentAtTheEnd(line,'#');
				StringTokenizer st = new StringTokenizer(line);
				String idString = st.nextToken();
				int id = Integer.valueOf(idString);
				String speciesName = st.nextToken();
				//CRNReducerCommandLine.println(out,bwOut,idString+" "+ speciesName);
				String initialPopulationString = st.nextToken();
				BigDecimal initialConcentration = BigDecimal.valueOf(evaluate(initialPopulationString));
				if(isSpecialNullSpecies(speciesName)){
					//we have the empty composite. We have to add the zero species to the CRN (only if it has not been already created)
					getCRN().getCreatingIfNecessaryTheZeroSpecies(speciesName);
				}
				else{
					ISpecies species=null;
					int currentId = id-1;
					if(compactNames){
						if(lowMemoryFootprint) {
							species = new SpeciesCompact(currentId, initialConcentration);
						}
						else {
							species = new Species("s"+currentId, speciesName,currentId, initialConcentration,initialPopulationString,false);
						}
						
						//speciesToLongName.put(species, speciesName);
						//species.addCommentLine("Original name: "+speciesName);
						if(bwSpeciesNames!=null){
							bwSpeciesNames.write("s"+currentId +"\t: "+speciesName+"\n");
						}
					}
					else{
						species = new Species(speciesName, currentId, initialConcentration,initialPopulationString,false);
					}
					getCRN().addSpecies(species);
				}
			}
			line = br.readLine();
		}
		if(bwSpeciesNames!=null){
			bwSpeciesNames.close();
		}
		getInfoImporting().setReadSpecies(getCRN().getSpecies().size());
		/*ISpecies[] allSpecies = new ISpecies[getCRN().getSpecies().size()];
		getCRN().getSpecies().toArray(allSpecies);
		return allSpecies;*/
	}
	
	/**
	 * It is assumed that the id of a species corresponds to the order with which it has been inserted: the i_th inserted species has id "i". 
	 * @param br
	 * @param uniqueBlock 
	 * @param crn
	 * @param math
	 * @param infoImporting
	 * @throws IOException
	 */
	private int loadReactions(BufferedReader br /*, ISpecies[] allSpecies*/) throws IOException {

		int n_ary=0;
		//boolean hasHomeoReactions=false;
		String line = br.readLine();//1 1,3 4 kon #Rule1
		while ((line != null) && (!(line=line.trim()).startsWith("end reactions"))) {
			//Skip comments or empty lines
			if(!(line.equals("") || line.startsWith("#"))){
				//System.out.println(line);
				line=removeCommentAtTheEnd(line,'#');

				StringTokenizer st = new StringTokenizer(line);
				//throw away the number of the reaction
				st.nextToken();
				//compute reagents
				String reagentsIdString = st.nextToken();
				String[] reagentsId = reagentsIdString.split(",");
				int arity = reagentsId.length;
				if(arity>1){
					n_ary++;
				}
				int[] reagentsIdInt = new int[arity];
				for(int i =0; i < arity;i++){
					int rIdInt = Integer.valueOf(reagentsId[i])-1;
					reagentsIdInt[i] = rIdInt;
					if(rIdInt == -1){
						//The special "zero" species
						ISpecies zeroSpecies = getCRN().getCreatingIfNecessaryTheZeroSpecies();
						rIdInt=zeroSpecies.getID();
						reagentsIdInt[i]=zeroSpecies.getID();
						reagentsId[i]=String.valueOf(zeroSpecies.getID());
					}
				}

				//compute products
				String productsIdString = st.nextToken();
				String[] productsId = productsIdString.split(",");
				int[] productsIdInt = new int[productsId.length];
				for(int i =0; i < productsIdInt.length;i++){
					int pIdInt = Integer.valueOf(productsId[i])-1;
					productsIdInt[i] = pIdInt;
					if(pIdInt == -1){
						//The special "zero" species
						ISpecies zeroSpecies = getCRN().getCreatingIfNecessaryTheZeroSpecies();
						pIdInt=zeroSpecies.getID();
						productsIdInt[i]=zeroSpecies.getID();
						productsId[i]=String.valueOf(zeroSpecies.getID());
					}
				}

				//compute rate of the reaction 
				String rateExpression = st.nextToken();
				BigDecimal reactionRate = MinusOne;
				//boolean hill=false;
				//In a previous version of the tool we had partial support for Hill kinetics //Hill k5 Ka n3 #20
				if(rateExpression.equalsIgnoreCase("Hill")){
					//k*x1^n/(K^n+x1^n)).
					throw new UnsupportedOperationException("BNG Hill reactions are not supported");
					/*String k = st.nextToken();
					String K = st.nextToken();
					String n = st.nextToken();
					//TODO WHY LIKE THIS?
					rateExpression = rateExpression + " " + k + " " + K + " " + n;
					hasHillKinetics = true;
					CRNReducerCommandLine.printWarning(out,"Warining: the model has a reaction with Hill kinetics: "+line);*/
				}
				else{
					reactionRate = BigDecimal.valueOf(evaluate(rateExpression));
				}
				//IComposite compositeReagents = new Composite(allSpecies,reagentsIdInt);
				IComposite compositeReagents = null;
				if(reagentsIdInt.length==1){
					compositeReagents=(IComposite)getCRN().getSpecies().get(reagentsIdInt[0]);
					//compositeReagents=(IComposite)allSpecies[reagentsIdInt[0]];
				}
				else{
					//compositeReagents = new Composite(allSpecies,reagentsIdInt);
					compositeReagents = new Composite(getCRN().getSpecies(),reagentsIdInt);
				}
//				if(CRNReducerCommandLine.univoqueReagents){
//					compositeReagents = getCRN().addReagentsIfNew(compositeReagents);
//				}
				//IComposite compositeProducts = new Composite(allSpecies,productsIdInt);
				IComposite compositeProducts = null;
				if(productsIdInt.length==1){
					compositeProducts=(IComposite)getCRN().getSpecies().get(productsIdInt[0]);
				}
				else{
					compositeProducts = new Composite(getCRN().getSpecies(),productsIdInt);
				}
//				if(CRNReducerCommandLine.univoqueProducts){
//					compositeProducts = getCRN().addProductIfNew(compositeProducts);
//				}
				
				ICRNReaction reaction;
				if(lowMemoryFootprint) {
					reaction = new CRNMassActionReactionCompact(reactionRate, compositeReagents, compositeProducts,rateExpression);
				}
				else {
					reaction = new CRNReaction(reactionRate, compositeReagents, compositeProducts, rateExpression,null);
				}
				
				/*if(compositeReagents.isBinary() && compositeReagents.getFirstReagent().equals(compositeReagents.getSecondReagent())){
					hasHomeoReactions=true;
				}*/
				addReaction(getCRN(),arity, reaction);
			}
			line = br.readLine();
		}
		getInfoImporting().setReadCRNReactions(getCRN().getReactions().size());
		//getInfoImporting().setReadReagents(getCRN().getReagents().size());
		//getInfoImporting().setReadProducts(getCRN().getProducts().size());
		
		/*if(hasHomeoReactions){
			System.out.println("HAS HOMEOREACTIONS");
		}*/
		return n_ary;
	}

	
	
	public static void printCRNToNetFile(ICRN crn, IPartition partition, boolean assignPopulationOfRepresentative, boolean groupAccordingToCurrentPartition, boolean verbose,MessageConsoleStream out,BufferedWriter bwOut){
		printCRNToNetFile(crn, partition, crn.getName(),assignPopulationOfRepresentative,groupAccordingToCurrentPartition,verbose,out,bwOut);
	}
	
	private static String toStringNetFileFormat(ICRNReaction reaction, HashMap<ISpecies, Integer> speciesToIdInNetFile, String parameterName) {
	
		String reagentsNet = toStringNetFileFormat(reaction.getReagents(),speciesToIdInNetFile);
		String productsNet = toStringNetFileFormat(reaction.getProducts(),speciesToIdInNetFile);
		
		return reagentsNet + " " + productsNet + " " + parameterName;
	}

	private static String toStringNetFileFormat(IComposite composite, HashMap<ISpecies, Integer> speciesToIdInNetFile) {
		
		if(composite.isUnary()){
			return String.valueOf(speciesToIdInNetFile.get(composite.getFirstReagent()));
		}
		else{
			//ISpecies[] allSpecies = composite.getAllSpecies();
			//int[] multiplicities = composite.getMultiplicities();
			
			if(composite.getNumberOfDifferentSpecies()==0){
				return "";
			}

			StringBuilder sb=new StringBuilder();
			
			for(int i =0;i< composite.getNumberOfDifferentSpecies();i++){
				ISpecies species = composite.getAllSpecies(i);
				int multiplicity = composite.getMultiplicities(i);
				int idInNetFile = speciesToIdInNetFile.get(species);
				if(multiplicity!=0){
					for(int m = 0;m<multiplicity;m++){
						sb.append(idInNetFile);
						sb.append(",");
					}
				}
			}
			if(sb.length()>0){
				//if(sb.charAt(sb.length()-1) ==','){
				sb.deleteCharAt(sb.length()-1);
				//}
			}
			else{
				return "0";
			}

			return sb.toString();
		}
	}
	
	/**
	 * A new id is assigned to the species, considering their order.
	 * @param crn
	 * @param partition
	 * @param name
	 * @param assignPopulationOfRepresentative
	 * @param groupAccordingToCurrentPartition
	 */
	public static void printCRNToNetFile(ICRN crn, IPartition partition,  String name, boolean assignPopulationOfRepresentative, boolean groupAccordingToCurrentPartition, boolean verbose,MessageConsoleStream out,BufferedWriter bwOut){
		String fileName = name;
		fileName=overwriteExtensionIfEnabled(fileName,".net");
		
		if(verbose){
			CRNReducerCommandLine.println(out,bwOut,"Writing model in file "+fileName);
		}

		HashMap<ISpecies, Integer> speciesToIdInNetFile = new HashMap<ISpecies, Integer>();
		HashMap<String, Integer> speciesNameToIdInNetFile = new HashMap<>();

		createParentDirectories(fileName);
		BufferedWriter bw;
		try {
			bw = new BufferedWriter(new FileWriter(fileName));
		} catch (IOException e) {
			CRNReducerCommandLine.println(out,bwOut,"Problems in printToNetFile, exception raised while creating the filewriter for file: "+fileName);
			CRNReducerCommandLine.printStackTrace(out,bwOut,e);
			return;
		}

		try {
			int parameterId=1;
			bw.write("begin parameters\n");
			for(String parameterDefinition : crn.getParameters()){
				bw.write("    "+parameterId+" "+parameterDefinition+"\n");
				parameterId++;
			}
			int r=0;
			for(ICRNReaction reaction : crn.getReactions()){
				r++;
				bw.write("    "+parameterId+" rateLaw"+r+" "+crn.getMath().evaluate(reaction.getRateExpression())+"\n");
				parameterId++;
			}
			/*//I first have to write the parameters. Unfortunately, it is not possible to use bare numbers as rates
			//For the moment I asusme that each crnReaction defines a parameter name
			for (ICRNReaction crnReaction : crn.getReactions()) {
				crnReaction.setRateExpression("param"+parameterId);
				br.write("    "+parameterId+" "+crnReaction.getRateExpression()+ " " + crnReaction.getRate()+"\n");
				parameterId++;
			}*/
			bw.write("end parameters\n\n");

			int idSpeciesInNetFile=1;
			bw.write("begin species\n");
			for (ISpecies species : crn.getSpecies()) {
				if(species.getComments()!=null){
					for(String comment : species.getComments()){
						writeCommentLine(bw, comment,"#");
					}
				}
				BigDecimal initialConcentration;
				if(assignPopulationOfRepresentative){
					initialConcentration = partition.getBlockOf(species).getRepresentative(CRNReducerCommandLine.COMPUTEREPRESENTATIVEBYMINOUTSIDEPARTITIONREFINEMENT).getInitialConcentration();
					//initialConcentration=BigDecimal.valueOf(10000);
				}
				else{
					initialConcentration = species.getInitialConcentration();
					//initialConcentration=BigDecimal.valueOf(10000);
				}
				
				bw.write("    "+idSpeciesInNetFile+" "+species.getName()+" "+ initialConcentration+"\n");
				speciesToIdInNetFile.put(species, idSpeciesInNetFile);
				speciesNameToIdInNetFile.put(species.getName(), idSpeciesInNetFile);
				//CRNReducerCommandLine.println(out,bwOut,"size: "+speciesToIdInNetFile.size()+" id:"+idSpeciesInNetFile);
				idSpeciesInNetFile++;
			}
			bw.write("end species\n\n");

			int reactionId=1;
			bw.write("begin reactions\n");
			for (ICRNReaction crnReaction : crn.getReactions()) {
				//br.write("    "+reactionId+" "+crnReaction.toStringNetFileFormat(speciesToIdInNetFile)+" #Reaction"+reactionId+"\n");
				bw.write("    "+reactionId+" "+toStringNetFileFormat(crnReaction,speciesToIdInNetFile,"rateLaw"+reactionId)+" #Reaction"+reactionId+"\n");
				reactionId++;
			}
			bw.write("end reactions\n\n");

			//Finally, I write a group per species (otherwise they will be labelled with random names)
			int groupId=0;
			if(groupAccordingToCurrentPartition){
				bw.write("begin groups\n");
				IBlock currentBlock = partition.getFirstBlock();
				while(currentBlock!=null){
					groupId++;
					bw.write(groupId+" ");
					bw.write(" " + toBNGGroup(currentBlock,speciesToIdInNetFile)+"\n");
					currentBlock=currentBlock.getNext();
				}
				bw.write("end groups\n\n");
			}
			else{
				if(crn.getViewNames()!=null && crn.getViewNames().length>0){
					Collection<String> skippedViews = new ArrayList<>();
					bw.write("begin groups\n");
					for(int i=0;i<crn.getViewNames().length;i++){
						//String group = fromSumViewToGroup(crn, crn.getViewNames()[i], crn.getViewExpressions()[i],speciesToIdInNetFile,out,skippedViews);
						String group = fromSumViewToGroup(crn, crn.getViewNames()[i], crn.getViewExpressions()[i],speciesNameToIdInNetFile,out,skippedViews);
						if(!group.equals("")){
							groupId++;
							bw.write(groupId+" ");
							bw.write(" "+crn.getViewNames()[i]);
							bw.write(" "+ group+"\n");
						}
					}
					if(!skippedViews.isEmpty()){
						StringBuilder sb = new StringBuilder(" (Ignored views:");
						for (String skippedView : skippedViews) {
							sb.append(" "+ skippedView );
						}
						sb.append(") ... ");
						CRNReducerCommandLine.print(out,bwOut,sb.toString());
					}
					bw.write("begin groups\n");
				}
				/*for (ISpecies species : crn.getSpecies()) {
					groupId++;
					br.write("    "+groupId+" "+species.getName().replace("~", "").replace(",", "")+" "+speciesToIdInNetFile.get(species)+"\n");
				}*/


			}
			
			GUICRNImporter.writeOriginalNames(crn, bw, "#");

		} catch (IOException e) {
			CRNReducerCommandLine.println(out,bwOut,"Problems in printToNetFile, exception raised while writing in the file: "+fileName);
			CRNReducerCommandLine.printStackTrace(out,bwOut,e);
			return;
		}
		finally{
			if(verbose){
				CRNReducerCommandLine.println(out,bwOut,"Writing reactions in file "+fileName+" completed");
			}
			try {
				bw.close();
			} catch (IOException e) {
				CRNReducerCommandLine.println(out,bwOut,"Problems in printToNetFile, exception raised while closing the bufferedwriter of the file: "+fileName);
				CRNReducerCommandLine.printStackTrace(out,bwOut,e);
			}
		}

	}

}
