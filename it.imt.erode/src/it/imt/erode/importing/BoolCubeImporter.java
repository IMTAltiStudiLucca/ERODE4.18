package it.imt.erode.importing;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map.Entry;

import javax.xml.stream.XMLStreamException;

import org.eclipse.ui.console.MessageConsoleStream;
import org.sbml.jsbml.ASTNode;
import org.sbml.jsbml.ASTNode.Type;
import org.sbml.jsbml.ListOf;
import org.sbml.jsbml.LocalParameter;
import org.sbml.jsbml.Model;
import org.sbml.jsbml.Reaction;
import org.sbml.jsbml.SBMLDocument;
import org.sbml.jsbml.SBMLReader;
import org.sbml.jsbml.SpeciesReference;

import it.imt.erode.commandline.CRNReducerCommandLine;
import it.imt.erode.commandline.IMessageDialogShower;
import it.imt.erode.crn.implementations.CRN;
import it.imt.erode.crn.implementations.Species;
import it.imt.erode.crn.interfaces.ICRN;
import it.imt.erode.crn.interfaces.ICRNReaction;
import it.imt.erode.crn.interfaces.ISpecies;
import it.imt.erode.expression.parser.IMonomial;
import it.imt.erode.expression.parser.MinusMonomial;
import it.imt.erode.expression.parser.NumberMonomial;
import it.imt.erode.expression.parser.ParameterMonomial;
import it.imt.erode.expression.parser.ProductMonomial;
import it.imt.erode.expression.parser.SpeciesMonomial;
import it.imt.erode.partition.implementations.Block;
import it.imt.erode.partition.implementations.Partition;
import it.imt.erode.partition.interfaces.IBlock;

/**
 * 
 * @author Andrea Vandin
 * This class is used to import the boolcube of boolean networks generated by the ODIfy tool, exported in the SBML format (file extension: .sbml).
 */
public class BoolCubeImporter extends AbstractImporter{

	public static final String BOOLCubeNetworksFolder = "."+File.separator+"BoolCubeSBMLNetworks"+File.separator;
	
	public BoolCubeImporter(String fileName,MessageConsoleStream out,BufferedWriter bwOut,IMessageDialogShower msgDialogShower) {
		super(fileName,out,bwOut,msgDialogShower);
	}
	
	public InfoCRNImporting importBoolCubeSBMLNetwork(boolean printInfo, boolean printCRN,boolean print) throws FileNotFoundException, IOException{
		if(print){
			CRNReducerCommandLine.println(out,bwOut,"\nImporting: "+getFileName());
		}
		
		initInfoImporting();
		initCRNAndMath();
		getInfoImporting().setLoadedCRN(true);
		
		
		SBMLDocument document;
		try {
			document = SBMLReader.read(new File(getFileName()));
		} catch (XMLStreamException e) {
			throw new IOException(e);
		}
		Model model = document.getModel();
		
		HashMap<String,ISpecies> namesToSpecies = loadSpecies(model);
		
		loadParameters(model);
		
		ISpecies I = new Species(Species.I_SPECIESNAME, getCRN().getSpeciesSize(), BigDecimal.ONE, "1",false);
		
		boolean needsToAddI= loadReactions(model,namesToSpecies,I);
		if(needsToAddI) {
			getCRN().addSpecies(I);
			namesToSpecies.put(Species.I_SPECIESNAME, I);
		}
		
		HashSet<ISpecies> possibleOutputs=computePossibleOutputs(getCRN());
		
		ArrayList<HashSet<ISpecies>> blocks = new ArrayList<HashSet<ISpecies>>(1);
		blocks.add(possibleOutputs);
		//blocks.add(others);
		getCRN().setUserDefinedPartition(blocks);
		
		IBlock uniqueBlock = new Block();
		setInitialPartition(new Partition(uniqueBlock,getCRN().getSpecies().size()));
		for (ISpecies species : getCRN().getSpecies()) {
			uniqueBlock.addSpecies(species);
		}
		
		if(print){
			if(printInfo){
				CRNReducerCommandLine.println(out,bwOut,getInfoImporting().toString());
			}
			if(printCRN){
				getCRN().printCRN();
			}
		}
		
		getInfoImporting().setReadSpecies(getCRN().getSpecies().size());
		return getInfoImporting();
	}
	
	private static boolean hasODEStructure(ICRNReaction r) {
			return  r.getReagents().getTotalMultiplicity()==1 && 
					r.getProducts().getTotalMultiplicity()==2 && 
					r.getProducts().getFirstReagent().equals(r.getProducts().getSecondReagent()) &&
					r.getProducts().getFirstReagent().equals(r.getReagents().getFirstReagent());	
	}

	public static HashSet<ISpecies> computePossibleOutputs(ICRN crn) {
		HashSet<ISpecies> possibleOutputs =new LinkedHashSet<ISpecies>(crn.getSpecies());
		BigDecimal MinusOne= new BigDecimal(-1);
		//HashSet<ISpecies> others=new LinkedHashSet<ISpecies>();
		//HashMap<ISpecies, ArrayList<ICRNReaction>> spReact=new LinkedHashMap<>(getCRN().getSpecies().size());
		for(ICRNReaction r: crn.getReactions()) {
			if(r.hasArbitraryKinetics()) {
				throw new UnsupportedOperationException("Possible outputs can be computed only for mass-action reactions");
			}
			//System.out.println(r);
			//Outputs can appear as reageants only in their decay reaction: s -> 2*s, -1
			if(hasODEStructure(r)) {
				//It is odelike. If rate is not -1, it can't be an output
				if(r.getRate().compareTo(MinusOne)!=0) {
					possibleOutputs.remove(r.getReagents().getFirstReagent());
				}
			}
			else {
				//the reagents can't be outputs
				for(int s=0;s<r.getReagents().getNumberOfDifferentSpecies();s++) {
					possibleOutputs.remove(r.getReagents().getAllSpecies(s));
				}
			}

			//			if(r.isODELike()) {
			//				throw new UnsupportedOperationException("reaction not supported: "+r);
			//			}
			//			else {
			//				ISpecies sp= r.getReagents().getFirstReagent();
			//				ArrayList<ICRNReaction> prev = spReact.get(sp);
			//				if(prev==null) {
			//					prev=new ArrayList<>();
			//					spReact.put(sp, prev);
			//				}
			//				prev.add(r);
			//			}
		}
		return possibleOutputs;

		//		for(Entry<ISpecies, ArrayList<ICRNReaction>> entry : spReact.entrySet()) {
		//			ISpecies sp = entry.getKey();
		//			ArrayList<ICRNReaction> reacts = entry.getValue();
		//			if(reacts.size()!=1) {
		//					possibleOutputs.remove(sp);
		//					//others.add(sp);
		//			}
		//			else if(reacts.size()==1) {
		//				if(reacts.get(0).getRate().compareTo(MinusOne)!=0) {
		//					possibleOutputs.remove(sp);
		//					//others.add(sp);
		//				}
		//			}
		//		}
		//		for(ISpecies sp : getCRN().getSpecies()) {
		//			if(!spReact.containsKey(sp)) {
		//				possibleOutputs.remove(sp);
		//				//others.add(sp);
		//			}
		//		}

		/*
		IPartition initial = new Partition(getCRN().getSpeciesSize());
		IBlock outputsBlock = new Block();
		//IBlock otherBlock = new Block();
		if(possibleOutputs.size()>0) {
			initial.add(outputsBlock);
			for(ISpecies sp : possibleOutputs) {
				outputsBlock.addSpecies(sp);
			}
		}
//		if(others.size()>0) {
//			initial.add(otherBlock);
//			for(ISpecies sp : others) {
//				otherBlock.addSpecies(sp);
//			}
//		}
		setInitialPartition(initial);
		 */
	}

	private void loadParameters(Model model) {
		//int count=0;
		LinkedHashMap<String, Double> paramsToValue=new LinkedHashMap<>();
		for (Reaction reaction : model.getListOfReactions()) {
			if (reaction.isSetKineticLaw()) {
				ListOf<LocalParameter> params = reaction.getKineticLaw().getListOfLocalParameters();
				for(LocalParameter p : params) {
					Double prev=paramsToValue.get(p.getName());
					if(prev==null) {
						paramsToValue.put(p.getName(), p.getValue());
					}
					else {
						if(prev!=p.getValue()) {
							throw new UnsupportedOperationException("Parameter "+p.getName()+" got at least two different values: "+prev+" and "+p.getValue());
						}
					}
					//System.out.println(p.getName()+"="+p.getValue());
				}
				//count += reaction.getKineticLaw().getLocalParameterCount();
			}
		}
		
		for(Entry<String, Double> entry:paramsToValue.entrySet()) {
			getCRN().addParameter(entry.getKey(), String.valueOf(entry.getValue()),true);
		}
		
	}

	private boolean loadReactions(Model model, HashMap<String, ISpecies> namesToSpecies, ISpecies I) {
		boolean needsToAddI=false;
		int reactionsNumber = model.getNumReactions();
		List<ICRNReaction> allReactions = new ArrayList<ICRNReaction>(reactionsNumber);//each sbml reaction will lead to at least a crn reaction (?)
		for(int r=0;r<reactionsNumber;r++){
			org.sbml.jsbml.Reaction sbmlReaction = model.getReaction(r);
			SpeciesReference product = sbmlReaction.getProduct(0);
			String name = product.getSpecies();
			ISpecies speciesOfODE = namesToSpecies.get(name);
			
//			if(name.equals("PLCg_a")){
//				System.out.println("ciao");
//			}

			ASTNode rateLaw = sbmlReaction.getKineticLaw().getMath();
			
			//Discard the division by param(i)
//			if(rateLaw.isOperator() && rateLaw.getType().equals(Type.DIVIDE)){
//				rateLaw=rateLaw.getLeftChild();
//			}

			ArrayList<IMonomial> monomials=parseOdefyODE(rateLaw,namesToSpecies);
			for (IMonomial monomial : monomials) {
				ICRNReaction reaction = monomial.toReaction(speciesOfODE,I).getReaction();
				if(reaction.getRate().compareTo(BigDecimal.ZERO)!=0){
					if(monomial.needsI()) {
						needsToAddI=true;
					}
					allReactions.add(reaction);
					/*
					getCRN().addReaction(reaction);
					addToIncomingReactionsOfProducts(reaction.getArity(),reaction.getProducts(), reaction,CRNReducerCommandLine.addReactionToComposites);
					addToOutgoingReactionsOfReagents(reaction.getArity(), reaction.getReagents(), reaction,CRNReducerCommandLine.addReactionToComposites);
					if(CRNReducerCommandLine.hasToAddToReactionsWithNonZeroStoichiometry){
						addToReactionsWithNonZeroStoichiometry(reaction.getArity(), reaction.computeProductsMinusReagentsHashMap(),reaction);
					}
					*/
				} 
			}			
		}
		
		CRN.collapseAndCombineAndAddReactions(getCRN(), allReactions, out,bwOut);
		getInfoImporting().setReadCRNReactions(getCRN().getReactions().size());
		return needsToAddI;
	}
	
	private ArrayList<IMonomial> parseOdefyODE(ASTNode node, HashMap<String, ISpecies> namesToSpecies) {
		//A variable is actually an ODE variable. I don't have parameters
		if(node.isOperator() && node.getChildCount()==2){
			Type type = node.getType();
			ArrayList<IMonomial> monomialsLeft = parseOdefyODE(node.getLeftChild(),namesToSpecies);
			ArrayList<IMonomial> monomialsRight = parseOdefyODE(node.getRightChild(),namesToSpecies);
 			if(type.equals(Type.TIMES)){
				//combine the two
				ArrayList<IMonomial> products = new ArrayList<>(monomialsLeft.size()*monomialsRight.size());
				for (IMonomial left : monomialsLeft) {
					for (IMonomial right : monomialsRight) {
						products.add(new ProductMonomial(left, right));
					}
				}
				return products;
			}
			else if(type.equals(Type.DIVIDE)) {
				//I only support divisions by a parameter
				if(monomialsRight.size()!=1) {
					throw new UnsupportedOperationException("We can divide only by a parameter");
				}
				else if(!monomialsRight.get(0).isParameter()) {
					throw new UnsupportedOperationException("We can divide only by a parameter");
				}
				//combine the two
				ArrayList<IMonomial> products = new ArrayList<>(monomialsLeft.size());
				String paramName=monomialsRight.get(0).toString();
				double paramValue= getCRN().getMath().evaluate(paramName);
				double oneVoerParam=1.0/paramValue;
				NumberMonomial oneOverdivisor= new NumberMonomial(BigDecimal.valueOf(oneVoerParam), "1/"+paramName);
				for (IMonomial left : monomialsLeft) {
					products.add(new ProductMonomial(left, oneOverdivisor));
				}
				return products;
			}
			else if(type.equals(Type.MINUS) ){
				for (IMonomial right : monomialsRight) {
					monomialsLeft.add(new MinusMonomial(right));
				}
				return monomialsLeft;
			}
			else if(type.equals(Type.PLUS) ){
				monomialsLeft.addAll(monomialsRight);
				return monomialsLeft;
			}
		}
		else if(node.isOperator() && node.getChildCount()==1 && node.getType().equals(Type.MINUS)){
			ArrayList<IMonomial> monomials = parseOdefyODE(node.getLeftChild(),namesToSpecies);
			ArrayList<IMonomial> ret = new ArrayList<>(monomials.size());
			for (IMonomial mon : monomials) {
				ret.add(new MinusMonomial(mon));
			}
			return ret;
		}
		else if(node.isVariable()){
			ArrayList<IMonomial> ret = new ArrayList<IMonomial>(1);
			ISpecies species=namesToSpecies.get(node.getName());
			if(species!=null) {
				ret.add(new SpeciesMonomial(species));
			}
			else {
				//It must be a parameter
				String name=node.getName();
				double val=getCRN().getMath().evaluate(name);
				ret.add(new ParameterMonomial(val, name));
			}
			
			return ret; 
		}
		else if(node.isNumber()){
			ArrayList<IMonomial> ret = new ArrayList<IMonomial>(1);
			ret.add(new NumberMonomial(BigDecimal.valueOf(node.getReal()),String.valueOf(node.getReal())));
			return ret;
		}

		throw new UnsupportedOperationException(node.toString());

	}

	private HashMap<String, ISpecies> loadSpecies(Model model) {
		int speciesNumber = model.getNumSpecies();
		HashMap<String, ISpecies> nameToSpecies=new HashMap<>(speciesNumber);
		int id=0;
		for(int i=0;i<speciesNumber;i++){
			org.sbml.jsbml.Species sbmlSpecies = model.getSpecies(i);
			String name = sbmlSpecies.getId();
			double initialConcentration = 0;
			if(sbmlSpecies.isSetInitialAmount()){
				initialConcentration = sbmlSpecies.getInitialConcentration();
			}
			if(Double.isNaN(initialConcentration)){
				initialConcentration=0;
			}
			ISpecies species = new Species(name,id,BigDecimal.valueOf(initialConcentration),String.valueOf(initialConcentration),false);
			getCRN().addSpecies(species);
			id++;
			nameToSpecies.put(name, species);
		}
		
//		ISpecies I = new Species(Species.I_SPECIESNAME, id, BigDecimal.ONE, "1",false);
//		getCRN().addSpecies(I);
//		id++;
//		nameToSpecies.put(Species.I_SPECIESNAME, I);
		
		getInfoImporting().setReadSpecies(getCRN().getSpecies().size());
		return nameToSpecies;
	}

	
}
