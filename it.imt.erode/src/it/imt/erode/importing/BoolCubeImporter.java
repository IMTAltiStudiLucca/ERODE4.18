package it.imt.erode.importing;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import javax.xml.stream.XMLStreamException;

import org.eclipse.ui.console.MessageConsoleStream;
import org.sbml.jsbml.ASTNode;
import org.sbml.jsbml.ASTNode.Type;
import org.sbml.jsbml.Model;
import org.sbml.jsbml.SBMLDocument;
import org.sbml.jsbml.SBMLReader;
import org.sbml.jsbml.SpeciesReference;

import it.imt.erode.commandline.CRNReducerCommandLine;
import it.imt.erode.commandline.IMessageDialogShower;
import it.imt.erode.crn.implementations.CRN;
import it.imt.erode.crn.implementations.Species;
import it.imt.erode.crn.interfaces.ICRNReaction;
import it.imt.erode.crn.interfaces.ISpecies;
import it.imt.erode.expression.parser.IMonomial;
import it.imt.erode.expression.parser.MinusMonomial;
import it.imt.erode.expression.parser.NumberMonomial;
import it.imt.erode.expression.parser.ProductMonomial;
import it.imt.erode.expression.parser.SpeciesMonomial;
import it.imt.erode.partition.implementations.Block;
import it.imt.erode.partition.implementations.Partition;
import it.imt.erode.partition.interfaces.IBlock;

/**
 * 
 * @author Andrea Vandin
 * This class is used to import the boolcube of boolean networks generated by the ODIfy tool, exported in the SBML format (file extension: .sbml).
 */
public class BoolCubeImporter extends AbstractImporter{

	public static final String BOOLCubeNetworksFolder = "."+File.separator+"BoolCubeSBMLNetworks"+File.separator;
	
	public BoolCubeImporter(String fileName,MessageConsoleStream out,BufferedWriter bwOut,IMessageDialogShower msgDialogShower) {
		super(fileName,out,bwOut,msgDialogShower);
	}
	
	public InfoCRNImporting importBoolCubeSBMLNetwork(boolean printInfo, boolean printCRN,boolean print) throws FileNotFoundException, IOException{
		if(print){
			CRNReducerCommandLine.println(out,bwOut,"\nImporting: "+getFileName());
		}
		
		initInfoImporting();
		initCRNAndMath();
		getInfoImporting().setLoadedCRN(true);
		
		
		SBMLDocument document;
		try {
			document = SBMLReader.read(new File(getFileName()));
		} catch (XMLStreamException e) {
			throw new IOException(e);
		}
		Model model = document.getModel();
		
		HashMap<String,ISpecies> namesToSpecies = loadSpecies(model);
		
		loadReactions(model,namesToSpecies,namesToSpecies.get(Species.I_SPECIESNAME));
		IBlock uniqueBlock = new Block();
		setInitialPartition(new Partition(uniqueBlock,getCRN().getSpecies().size()));
		for (ISpecies species : getCRN().getSpecies()) {
			uniqueBlock.addSpecies(species);
		}
		
		if(print){
			if(printInfo){
				CRNReducerCommandLine.println(out,bwOut,getInfoImporting().toString());
			}
			if(printCRN){
				getCRN().printCRN();
			}
		}
		
		getInfoImporting().setReadSpecies(getCRN().getSpecies().size());
		return getInfoImporting();
	}

	private void loadReactions(Model model, HashMap<String, ISpecies> namesToSpecies, ISpecies I) {
		int reactionsNumber = model.getNumReactions();
		List<ICRNReaction> allReactions = new ArrayList<ICRNReaction>(reactionsNumber);//each sbml reaction will lead to at least a crn reaction (?)
		for(int r=0;r<reactionsNumber;r++){
			org.sbml.jsbml.Reaction sbmlReaction = model.getReaction(r);
			SpeciesReference product = sbmlReaction.getProduct(0);
			String name = product.getSpecies();
			ISpecies speciesOfODE = namesToSpecies.get(name);
			
			if(name.equals("PLCg_a")){
				System.out.println("ciao");
			}

			ASTNode rateLaw = sbmlReaction.getKineticLaw().getMath();
			
			//Discard the division by param(i)
			if(rateLaw.isOperator() && rateLaw.getType().equals(Type.DIVIDE)){
				rateLaw=rateLaw.getLeftChild();
			}

			ArrayList<IMonomial> monomials=parseOdefyODE(rateLaw,namesToSpecies);
			for (IMonomial monomial : monomials) {
				ICRNReaction reaction = monomial.toReaction(speciesOfODE,I).getReaction();
				if(reaction.getRate().compareTo(BigDecimal.ZERO)!=0){
					allReactions.add(reaction);
					/*
					getCRN().addReaction(reaction);
					addToIncomingReactionsOfProducts(reaction.getArity(),reaction.getProducts(), reaction,CRNReducerCommandLine.addReactionToComposites);
					addToOutgoingReactionsOfReagents(reaction.getArity(), reaction.getReagents(), reaction,CRNReducerCommandLine.addReactionToComposites);
					if(CRNReducerCommandLine.hasToAddToReactionsWithNonZeroStoichiometry){
						addToReactionsWithNonZeroStoichiometry(reaction.getArity(), reaction.computeProductsMinusReagentsHashMap(),reaction);
					}
					*/
				} 
			}			
		}
		
		CRN.collapseAndCombineAndAddReactions(getCRN(), allReactions, out,bwOut);
		getInfoImporting().setReadCRNReactions(getCRN().getReactions().size());
	}
	
	private ArrayList<IMonomial> parseOdefyODE(ASTNode node, HashMap<String, ISpecies> namesToSpecies) {
		//A variable is actually an ODE variable. I don't have parameters
		if(node.isOperator() && node.getChildCount()==2){
			Type type = node.getType();
			ArrayList<IMonomial> monomialsLeft = parseOdefyODE(node.getLeftChild(),namesToSpecies);
			ArrayList<IMonomial> monomialsRight = parseOdefyODE(node.getRightChild(),namesToSpecies);
			if(type.equals(Type.TIMES)){
				//combine the two
				ArrayList<IMonomial> products = new ArrayList<>(monomialsLeft.size()*monomialsRight.size());
				for (IMonomial left : monomialsLeft) {
					for (IMonomial right : monomialsRight) {
						products.add(new ProductMonomial(left, right));
					}
				}
				return products;
			}
			else if(type.equals(Type.MINUS) ){
				for (IMonomial right : monomialsRight) {
					monomialsLeft.add(new MinusMonomial(right));
				}
				return monomialsLeft;
			}
			else if(type.equals(Type.PLUS) ){
				monomialsLeft.addAll(monomialsRight);
				return monomialsLeft;
			}
		}
		else if(node.isOperator() && node.getChildCount()==1 && node.getType().equals(Type.MINUS)){
			ArrayList<IMonomial> monomials = parseOdefyODE(node.getLeftChild(),namesToSpecies);
			ArrayList<IMonomial> ret = new ArrayList<>(monomials.size());
			for (IMonomial mon : monomials) {
				ret.add(new MinusMonomial(mon));
			}
			return ret;
		}
		else if(node.isVariable()){
			ArrayList<IMonomial> ret = new ArrayList<IMonomial>(1);
			ret.add(new SpeciesMonomial(namesToSpecies.get(node.getName())));
			return ret; 
		}
		else if(node.isNumber()){
			ArrayList<IMonomial> ret = new ArrayList<IMonomial>(1);
			ret.add(new NumberMonomial(BigDecimal.valueOf(node.getReal()),String.valueOf(node.getReal())));
			return ret;
		}

		throw new UnsupportedOperationException(node.toString());

	}

	private HashMap<String, ISpecies> loadSpecies(Model model) {
		int speciesNumber = model.getNumSpecies();
		HashMap<String, ISpecies> nameToSpecies=new HashMap<>(speciesNumber);
		int id=0;
		for(int i=0;i<speciesNumber;i++){
			org.sbml.jsbml.Species sbmlSpecies = model.getSpecies(i);
			String name = sbmlSpecies.getId();
			double initialConcentration = 0;
			if(sbmlSpecies.isSetInitialAmount()){
				initialConcentration = sbmlSpecies.getInitialConcentration();
			}
			if(Double.isNaN(initialConcentration)){
				initialConcentration=0;
			}
			ISpecies species = new Species(name,id,BigDecimal.valueOf(initialConcentration),String.valueOf(initialConcentration),false);
			getCRN().addSpecies(species);
			id++;
			nameToSpecies.put(name, species);
		}
		
		ISpecies I = new Species(Species.I_SPECIESNAME, id, BigDecimal.ONE, "1",false);
		getCRN().addSpecies(I);
		id++;
		nameToSpecies.put(Species.I_SPECIESNAME, I);
		
		getInfoImporting().setReadSpecies(getCRN().getSpecies().size());
		return nameToSpecies;
	}

	
}
