/*
 * generated by Xtext 2.20.0
 */
package it.imt.erode.crn.validation;

import com.google.common.collect.Iterables;

import it.imt.erode.crn.chemicalReactionNetwork.ALG;
import it.imt.erode.crn.chemicalReactionNetwork.AbsTol;
import it.imt.erode.crn.chemicalReactionNetwork.AlgSpecies;
import it.imt.erode.crn.chemicalReactionNetwork.AlgebraicList;
import it.imt.erode.crn.chemicalReactionNetwork.Analysis;
import it.imt.erode.crn.chemicalReactionNetwork.Block;
import it.imt.erode.crn.chemicalReactionNetwork.CSVFile;
import it.imt.erode.crn.chemicalReactionNetwork.ChemicalReactionNetworkPackage;
import it.imt.erode.crn.chemicalReactionNetwork.Composite;
import it.imt.erode.crn.chemicalReactionNetwork.ComputeJacobian;
import it.imt.erode.crn.chemicalReactionNetwork.DefaultIC;
import it.imt.erode.crn.chemicalReactionNetwork.Export;
import it.imt.erode.crn.chemicalReactionNetwork.FileRed;
import it.imt.erode.crn.chemicalReactionNetwork.ICList;
import it.imt.erode.crn.chemicalReactionNetwork.Import;
import it.imt.erode.crn.chemicalReactionNetwork.InitPartition;
import it.imt.erode.crn.chemicalReactionNetwork.Limits;
import it.imt.erode.crn.chemicalReactionNetwork.MVNode;
import it.imt.erode.crn.chemicalReactionNetwork.MVNodeDeclarations;
import it.imt.erode.crn.chemicalReactionNetwork.MVNodeDefinition;
import it.imt.erode.crn.chemicalReactionNetwork.MVNodeDefinitions;
import it.imt.erode.crn.chemicalReactionNetwork.MVUpdateFunctions;
import it.imt.erode.crn.chemicalReactionNetwork.MassActionRate;
import it.imt.erode.crn.chemicalReactionNetwork.MassActionReduction;
import it.imt.erode.crn.chemicalReactionNetwork.MaxStep;
import it.imt.erode.crn.chemicalReactionNetwork.Method;
import it.imt.erode.crn.chemicalReactionNetwork.MinStep;
import it.imt.erode.crn.chemicalReactionNetwork.ModelDefinition;
import it.imt.erode.crn.chemicalReactionNetwork.Node;
import it.imt.erode.crn.chemicalReactionNetwork.NodeDeclarations;
import it.imt.erode.crn.chemicalReactionNetwork.NodeDefinition;
import it.imt.erode.crn.chemicalReactionNetwork.NodeDefinitions;
import it.imt.erode.crn.chemicalReactionNetwork.ODE;
import it.imt.erode.crn.chemicalReactionNetwork.ODEsList;
import it.imt.erode.crn.chemicalReactionNetwork.OptionalParametersReductions;
import it.imt.erode.crn.chemicalReactionNetwork.OptionalParametersUtopic;
import it.imt.erode.crn.chemicalReactionNetwork.Parameter;
import it.imt.erode.crn.chemicalReactionNetwork.ParameterWithBound;
import it.imt.erode.crn.chemicalReactionNetwork.ParametersSimulateCTMC;
import it.imt.erode.crn.chemicalReactionNetwork.ParametersSimulateODE;
import it.imt.erode.crn.chemicalReactionNetwork.Prep;
import it.imt.erode.crn.chemicalReactionNetwork.RateOfReaction;
import it.imt.erode.crn.chemicalReactionNetwork.Reaction;
import it.imt.erode.crn.chemicalReactionNetwork.ReactionsList;
import it.imt.erode.crn.chemicalReactionNetwork.Reduction;
import it.imt.erode.crn.chemicalReactionNetwork.ReductionAlgorithm;
import it.imt.erode.crn.chemicalReactionNetwork.RelsTol;
import it.imt.erode.crn.chemicalReactionNetwork.Repeats;
import it.imt.erode.crn.chemicalReactionNetwork.SolverLibrary;
import it.imt.erode.crn.chemicalReactionNetwork.Species;
import it.imt.erode.crn.chemicalReactionNetwork.SpeciesAndExpression;
import it.imt.erode.crn.chemicalReactionNetwork.SpeciesOrNode;
import it.imt.erode.crn.chemicalReactionNetwork.SpeciesWithMultiplicity;
import it.imt.erode.crn.chemicalReactionNetwork.SpeciesWithNumber;
import it.imt.erode.crn.chemicalReactionNetwork.StepSize;
import it.imt.erode.crn.chemicalReactionNetwork.Steps;
import it.imt.erode.crn.chemicalReactionNetwork.SymbolicParameter;
import it.imt.erode.crn.chemicalReactionNetwork.SymbolicParametersList;
import it.imt.erode.crn.chemicalReactionNetwork.UpdateStatusCommand;
import it.imt.erode.crn.chemicalReactionNetwork.ViewsList;
import it.imt.erode.crn.chemicalReactionNetwork.VisualizePlot;
import it.imt.erode.crn.chemicalReactionNetwork.caseMV;
import it.imt.erode.crn.chemicalReactionNetwork.decompress;
import it.imt.erode.crn.chemicalReactionNetwork.exportBNG;
import it.imt.erode.crn.chemicalReactionNetwork.exportC2E2;
import it.imt.erode.crn.chemicalReactionNetwork.exportLBS;
import it.imt.erode.crn.chemicalReactionNetwork.exportPontryaginPolygonMethod;
import it.imt.erode.crn.chemicalReactionNetwork.importMRMC;
import it.imt.erode.crn.chemicalReactionNetwork.reduceBDE;
import it.imt.erode.crn.chemicalReactionNetwork.reduceFBE;
import it.imt.erode.crn.chemicalReactionNetwork.reduceFME;
import it.imt.erode.crn.chemicalReactionNetwork.reduceUncertainFE;
import it.imt.erode.crn.chemicalReactionNetwork.simulateCTMC;
import it.imt.erode.crn.chemicalReactionNetwork.simulateDAE;
import it.imt.erode.crn.chemicalReactionNetwork.simulateODE;
import it.imt.erode.crn.chemicalReactionNetwork.utopic;
import it.imt.erode.crn.chemicalReactionNetwork.utopicEpsilon;
import it.imt.erode.crn.chemicalReactionNetwork.utopicKMax;
import it.imt.erode.crn.chemicalReactionNetwork.utopicMaxStep;
import it.imt.erode.crn.chemicalReactionNetwork.utopicSymbolicJacobian;
//import it.imt.erode.crn.validation.AbstractChemicalReactionNetworkValidator;
//import it.imt.erode.crn.validation.MyValidatorUtil;
//import it.imt.erode.crn.validation.PosAndMessage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class ChemicalReactionNetworkValidator extends AbstractChemicalReactionNetworkValidator {

	//	public static final INVALID_NAME = 'invalidName'
	//
	//	@Check
	//	public void checkGreetingStartsWithCapital(Greeting greeting) {
	//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
	//			warning("Name should start with a capital",
	//					ChemicalReactionNetworkPackage.Literals.GREETING__NAME,
	//					INVALID_NAME);
	//		}
	//	}

	public static final String NAME_NOT_STARTING_WITH_LETTER = "nameNotStartingWithLetter";

	public static final String E_NAME = "eAsNAme";

	public static final String DEC_NAME = "decAsNAme";

	public static final String Gamma_NAME = "GammaAsNAme";

	public static final String DUPLICATE_NAMES = "duplicateNames";

	public static final String UNDEFINED_SPECIES = "undefinedSpecies";

	public static final String DUPLICATE_OPTIONAL_PARAMETER_REDUCTION = "duplicateParameterOfReduction";

	public static final String DUPLICATE_IC = "duplicateIC";

	public static final String REDUCTION_TERNARYORMORE = "elementaryReductionAndTernaryCRN";

	public static final String REDUCTION_MASSCTION = "massActionReductionAndNonMassActionCRN";

	public static final String DUPLICATE_ODE = "moreThanOneODEPErAVariable";

	public static final String MISSING_DRIFT = "mmissingDrift";

	public static final String MISSING_DRIFTS = "mmissingDrifts";

	public static final String ANALYSIS_SYMBOLIC = "analysisOfModelsWithSymbolicParameters";

	public static final String EXPORT_SYMBOLIC = "exportOfModelsWithSymbolicParameters";

	public static final String SIMULATEODE_ALGEBRAIC = "simulateODEwithAlgebraic";

	/**
	 * @Check
	 * def checkEName(ParameterOrSpecies ps) {
	 * var ps2 = ps as ParameterOrSymbolicParameterOrSpecies
	 * var name = ps2.name.trim();
	 * if(name.equalsIgnoreCase("e")){
	 * //CRNReducerCommandLine.printWarning("The use of \"e\" or \"E\" as name of a parameter is deprecated, as expressions containing it might be erroneously considered as numbers in scientific notation.");
	 * warning("The use of \"e\" or \"E\" as name of species or parameters is deprecated, as expressions containing it might be erroneously considered as numbers in scientific notation",
	 * //ChemicalReactionNetworkPackage.Literals.PARAMETER_OR_SPECIES__NAME//AchievementPackage.Literals.TEXT__TEXT,
	 * ChemicalReactionNetworkPackage.Literals.PARAMETER_OR_SYMBOLIC_PARAMETER_OR_SPECIES__NAME
	 * ,E_NAME);
	 * }
	 * }
	 */
	public boolean startsWithLetter(final String name) {
		char c = name.charAt(0);
		return (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')));
	}

	@Check
	public void checkEName(final Parameter ps) {
		String name = ps.getName().trim();
		boolean _equalsIgnoreCase = name.equalsIgnoreCase("e");
		if (_equalsIgnoreCase) {
			this.warning("The use of \"e\" or \"E\" as name of parameters is deprecated, as expressions containing it might be erroneously considered as numbers in scientific notation", 
					ChemicalReactionNetworkPackage.eINSTANCE.getParameter_Name(), ChemicalReactionNetworkValidator.E_NAME);
		} else {
			boolean _startsWithLetter = this.startsWithLetter(name);
			boolean _not = (!_startsWithLetter);
			if (_not) {
				this.error("Names should start with a letter.", 
						ChemicalReactionNetworkPackage.eINSTANCE.getParameter_Name(), ChemicalReactionNetworkValidator.NAME_NOT_STARTING_WITH_LETTER);
			}
		}
	}

	@Check
	public void checkGammaName(final Parameter ps) {
		String name = ps.getName().trim();
		boolean _equalsIgnoreCase = name.equalsIgnoreCase("gamma");
		if (_equalsIgnoreCase) {
			this.warning("The use of \"gamma\" as name of parameters is deprecated", 
					ChemicalReactionNetworkPackage.eINSTANCE.getParameter_Name(), ChemicalReactionNetworkValidator.Gamma_NAME);
		} else {
			boolean _startsWithLetter = this.startsWithLetter(name);
			boolean _not = (!_startsWithLetter);
			if (_not) {
				this.error("Names should start with a letter.", 
						ChemicalReactionNetworkPackage.eINSTANCE.getParameter_Name(), ChemicalReactionNetworkValidator.NAME_NOT_STARTING_WITH_LETTER);
			}
		}
	}

	@Check
	public void checkEName(final SymbolicParameter ps) {
		String name = ps.getName().trim();
		boolean _equalsIgnoreCase = name.equalsIgnoreCase("e");
		if (_equalsIgnoreCase) {
			this.warning("The use of \"e\" or \"E\" as name of parameters is deprecated, as expressions containing it might be erroneously considered as numbers in scientific notation", 
					ChemicalReactionNetworkPackage.eINSTANCE.getSymbolicParameter_Name(), ChemicalReactionNetworkValidator.E_NAME);
		} else {
			boolean _startsWithLetter = this.startsWithLetter(name);
			boolean _not = (!_startsWithLetter);
			if (_not) {
				this.error("Names should start with a letter.", 
						ChemicalReactionNetworkPackage.eINSTANCE.getParameter_Name(), ChemicalReactionNetworkValidator.NAME_NOT_STARTING_WITH_LETTER);
			}
		}
	}

	@Check
	public void checkEName(final Species ps) {
		String name = ps.getName().trim();
		boolean _equalsIgnoreCase = name.equalsIgnoreCase("e");
		if (_equalsIgnoreCase) {
			this.warning("The use of \"e\" or \"E\" as name of species is deprecated, as expressions containing it might be erroneously considered as numbers in scientific notation", 
					ChemicalReactionNetworkPackage.eINSTANCE.getSpeciesOrNode_Name(), ChemicalReactionNetworkValidator.E_NAME);
		} else {
			boolean _startsWithLetter = this.startsWithLetter(name);
			boolean _not = (!_startsWithLetter);
			if (_not) {
				this.error("Names should start with a letter.", 
						ChemicalReactionNetworkPackage.eINSTANCE.getSpeciesOrNode_Name(), ChemicalReactionNetworkValidator.NAME_NOT_STARTING_WITH_LETTER);
			}
		}
	}

	@Check
	public void checkEName(final AlgSpecies ps) {
		String name = ps.getName().trim();
		boolean _equalsIgnoreCase = name.equalsIgnoreCase("e");
		if (_equalsIgnoreCase) {
			this.warning("The use of \"e\" or \"E\" as name of species is deprecated, as expressions containing it might be erroneously considered as numbers in scientific notation", 
					ChemicalReactionNetworkPackage.eINSTANCE.getSpeciesOrNode_Name(), ChemicalReactionNetworkValidator.E_NAME);
		} else {
			boolean _startsWithLetter = this.startsWithLetter(name);
			boolean _not = (!_startsWithLetter);
			if (_not) {
				this.error("Names should start with a letter.", 
						ChemicalReactionNetworkPackage.eINSTANCE.getAlgSpecies_Name(), ChemicalReactionNetworkValidator.NAME_NOT_STARTING_WITH_LETTER);
			}
		}
	}

	/**
	 * @Check
	 * def checkEName(ParameterOrSymbolicParameterOrSpecies ps) {
	 * var name = ps.name.trim();
	 * if(name.equalsIgnoreCase("e")){
	 * //CRNReducerCommandLine.printWarning("The use of \"e\" or \"E\" as name of a parameter is deprecated, as expressions containing it might be erroneously considered as numbers in scientific notation.");
	 * warning("The use of \"e\" or \"E\" as name of species or parameters is deprecated, as expressions containing it might be erroneously considered as numbers in scientific notation",
	 * //ChemicalReactionNetworkPackage.Literals.PARAMETER_OR_SPECIES__NAME//AchievementPackage.Literals.TEXT__TEXT,
	 * ChemicalReactionNetworkPackage.Literals.PARAMETER_OR_SYMBOLIC_PARAMETER_OR_SPECIES__NAME
	 * ,E_NAME);
	 * }
	 * }
	 */
	//	@Check
	//	public void checkDecName(final Species ps) {
	//		String name = ps.getName().trim();
	//		String lowerName = name.toLowerCase();
	//		boolean _startsWith = lowerName.startsWith("dec");
	//		if (_startsWith) {
	//			if ((((((((((lowerName.startsWith("dec0") || lowerName.startsWith("dec1")) || lowerName.startsWith("dec2")) || lowerName.startsWith("dec3")) || 
	//					lowerName.startsWith("dec4")) || lowerName.startsWith("dec5")) || lowerName.startsWith("dec6")) || lowerName.startsWith("dec7")) || 
	//					lowerName.startsWith("dec8")) || lowerName.startsWith("dec9"))) {
	//				this.warning("The use of \"Dec\" followed by a number as name of species is deprecated", 
	//						ChemicalReactionNetworkPackage.eINSTANCE.getSpeciesOrNode_Name(), ChemicalReactionNetworkValidator.DEC_NAME);
	//			}
	//		}
	//	}

	@Check
	public void checkDecoder(final decompress elem) {
		int pos = (-1);
		int j = 0;
		Limits limits = elem.getLimits();
		EList<SpeciesWithNumber> allSpecies = limits.getLimitOfSpecies();
		HashSet<String> duplicates = new HashSet<String>();
		if (((allSpecies != null) && (allSpecies.size() > 0))) {
			int _size = allSpecies.size();
			HashSet<String> set = new HashSet<String>(_size);
			for (final SpeciesWithNumber species : allSpecies) {
				{
					String name = species.getSpecies().getName();
					boolean _contains = set.contains(name);
					if (_contains) {
						duplicates.add(name);
						pos = j;
					} else {
						set.add(name);
					}
					j++;
				}
			}
		}
		if ((pos != (-1))) {
			String msg = duplicates.toString();
			int _length = msg.length();
			int _minus = (_length - 1);
			msg = msg.substring(1, _minus);
			int _size_1 = duplicates.size();
			boolean _equals = (_size_1 == 1);
			if (_equals) {
				msg = ("Duplicate limit for species " + msg);
			} else {
				msg = ("Duplicate limits for species " + msg);
			}
			PosAndMessage pam = new PosAndMessage(pos, msg);
			this.error(
					pam.getMsg(), 
					ChemicalReactionNetworkPackage.eINSTANCE.getdecompress_Limits(), 
					pam.getPos());
		}
	}

	public PosAndMessage checkUniqueParameterToPerturb(final EList<ParameterWithBound> paramsToPerturb) {
		int pos = (-1);
		int j = 0;
		int _size = paramsToPerturb.size();
		HashSet<String> setOfParamsToPerturb = new HashSet<String>(_size);
		HashSet<String> duplicateParameter = new HashSet<String>();
		for (final ParameterWithBound paramToPerturb : paramsToPerturb) {
			{
				String name = paramToPerturb.getParam().getName();
				boolean _contains = setOfParamsToPerturb.contains(name);
				if (_contains) {
					duplicateParameter.add(name);
					pos = j;
				} else {
					setOfParamsToPerturb.add(name);
				}
				j++;
			}
		}
		if ((pos != (-1))) {
			String msg = duplicateParameter.toString();
			int _length = msg.length();
			int _minus = (_length - 1);
			msg = msg.substring(1, _minus);
			int _size_1 = duplicateParameter.size();
			boolean _equals = (_size_1 == 1);
			if (_equals) {
				msg = ("Duplicate parameter to perturb " + msg);
			} else {
				msg = ("Duplicate parameters to perturb " + msg);
			}
			return new PosAndMessage(pos, msg);
		} else {
			return null;
		}
	}

	@Check
	public void checkUniqueC2E2Exporter(final exportC2E2 elem) {
		EList<ParameterWithBound> paramsToPerturb = elem.getParamsToPerturb().getParamsToPerturb();
		PosAndMessage pam = this.checkUniqueParameterToPerturb(paramsToPerturb);
		if ((pam != null)) {
			this.error(
					pam.getMsg(), 
					ChemicalReactionNetworkPackage.eINSTANCE.getexportC2E2_ParamsToPerturb(), 
					pam.getPos());
		}
	}

	@Check
	public void checkUniqueParameterToPerturbAndCoefficient(final utopic elem) {
		EList<ParameterWithBound> paramsToPerturb = elem.getParamsToPerturb().getParamsToPerturb();
		int pos = 0;
		int i = 0;
		HashSet<String> duplicateOptionalParameter = new HashSet<String>();
		PosAndMessage pam = this.checkUniqueParameterToPerturb(paramsToPerturb);
		if ((pam != null)) {
			this.error(
					pam.getMsg(), 
					ChemicalReactionNetworkPackage.eINSTANCE.getutopic_ParamsToPerturb(), 
					pam.getPos());
		}
		double epsilon = 0.0;
		int nEps = 0;
		int nKMax = 0;
		int nJac = 0;
		int nMaxStep = 0;
		EList<OptionalParametersUtopic> optionalParams = elem.getOptionalParams();
		if ((optionalParams != null)) {
			for (final OptionalParametersUtopic optionalParamUtopic : optionalParams) {
				{
					i++;
					if ((optionalParamUtopic instanceof utopicKMax)) {
						nKMax++;
						if ((nKMax > 1)) {
							pos = i;
							duplicateOptionalParameter.add("kMax");
						}
					} else {
						if ((optionalParamUtopic instanceof utopicEpsilon)) {
							nEps++;
							if ((nEps > 1)) {
								pos = i;
								duplicateOptionalParameter.add("epsilon");
							}
							epsilon = ((utopicEpsilon)optionalParamUtopic).getEpsilon();
						} else {
							if ((optionalParamUtopic instanceof utopicMaxStep)) {
								nMaxStep++;
								if ((nMaxStep > 1)) {
									pos = i;
									duplicateOptionalParameter.add("nMaxStep");
								}
							} else {
								if ((optionalParamUtopic instanceof utopicSymbolicJacobian)) {
									nJac++;
									if ((nJac > 1)) {
										pos = i;
										duplicateOptionalParameter.add("symbolicJacobian");
									}
								}
							}
						}
					}
				}
			}
		}
		if (((((nKMax > 1) || (nEps > 1)) || (nMaxStep > 1)) || (nJac > 1))) {
			String msg = duplicateOptionalParameter.toString();
			int _length = msg.length();
			int _minus = (_length - 1);
			msg = msg.substring(1, _minus);
			int _size = duplicateOptionalParameter.size();
			boolean _equals = (_size == 1);
			if (_equals) {
				msg = ("Duplicate parameter " + msg);
			} else {
				msg = ("Duplicate parameters " + msg);
			}
			this.error(msg, 
					ChemicalReactionNetworkPackage.eINSTANCE.getutopic_OptionalParams());
		}
		if ((nEps > 0)) {
			if (((epsilon < 0) || (epsilon >= 1))) {
				this.error(
						"The threshold epsilon must belong to the interval (0,1)", 
						ChemicalReactionNetworkPackage.eINSTANCE.getutopic_OptionalParams());
			}
		}
		pos = (-1);
		int j = 0;
		EList<SpeciesAndExpression> coefficients = elem.getCoefficients().getCoefficients();
		int _size_1 = coefficients.size();
		HashSet<String> setOfCoeffs = new HashSet<String>(_size_1);
		HashSet<String> duplicateCoefficient = new HashSet<String>();
		for (final SpeciesAndExpression coeff : coefficients) {
			{
				String name = coeff.getSpecies().getName();
				boolean _contains = setOfCoeffs.contains(name);
				if (_contains) {
					duplicateCoefficient.add(name);
					pos = j;
				} else {
					setOfCoeffs.add(name);
				}
				j++;
			}
		}
		if ((pos != (-1))) {
			String msg_1 = duplicateCoefficient.toString();
			int _length_1 = msg_1.length();
			int _minus_1 = (_length_1 - 1);
			msg_1 = msg_1.substring(1, _minus_1);
			msg_1 = ("More than one coefficient for the species " + msg_1);
			this.error(msg_1, 
					ChemicalReactionNetworkPackage.eINSTANCE.getutopic_Coefficients(), pos);
		}
	}

	@Check
	public void checkUniqueParameterToPerturb(final exportPontryaginPolygonMethod elem) {
		int pos = (-1);
		int j = 0;
		EList<ParameterWithBound> paramsToPerturb = elem.getParamsToPerturb().getParamsToPerturb();
		int _size = paramsToPerturb.size();
		HashSet<String> setOfParamsToPerturb = new HashSet<String>(_size);
		HashSet<String> duplicateParameter = new HashSet<String>();
		for (final ParameterWithBound paramToPerturb : paramsToPerturb) {
			{
				String name = paramToPerturb.getParam().getName();
				boolean _contains = setOfParamsToPerturb.contains(name);
				if (_contains) {
					duplicateParameter.add(name);
					pos = j;
				} else {
					setOfParamsToPerturb.add(name);
				}
				j++;
			}
		}
		if ((pos != (-1))) {
			String msg = duplicateParameter.toString();
			int _length = msg.length();
			int _minus = (_length - 1);
			msg = msg.substring(1, _minus);
			int _size_1 = duplicateParameter.size();
			boolean _equals = (_size_1 == 1);
			if (_equals) {
				msg = ("Duplicate parameter to perturb " + msg);
			} else {
				msg = ("Duplicate parameters to perturb " + msg);
			}
			this.error(msg, 
					ChemicalReactionNetworkPackage.eINSTANCE.getexportPontryaginPolygonMethod_ParamsToPerturb(), pos);
		}
	}

	@Check
	public void checkUniqueParametersOfReduction(final Reduction red) {
		int nPrep = 0;
		int redFile = 0;
		int grFile = 0;
		int sameICFile = 0;
		int fileIn = 0;
		int onlyP = 0;
		int filePart = 0;
		int info = 0;
		int reductionAlgorithm = 0;
		int pos = 0;
		int i = pos;
		EList<OptionalParametersReductions> optionalParameters = red.getOptionalParametersFormatted().getOptionalParameters();
		int _size = optionalParameters.size();
		HashSet<String> duplicateParameter = new HashSet<String>(_size);
		for (final OptionalParametersReductions par : optionalParameters) {
			{
				i++;
				if ((par instanceof FileRed)) {
					redFile++;
					if ((redFile > 1)) {
						pos = i;
						duplicateParameter.add("reducedFile");
					}
				} else {
					if ((par instanceof Prep)) {
						nPrep++;
						if ((nPrep > 1)) {
							pos = i;
							duplicateParameter.add("prePartition");
						}
					} else {
						if ((par instanceof ReductionAlgorithm)) {
							reductionAlgorithm++;
							if ((reductionAlgorithm > 1)) {
								pos = i;
								duplicateParameter.add("reductionAlgorithm");
							}
						}
					}
				}
			}
		}
		if ((((((((((nPrep > 1) || (redFile > 1)) || (grFile > 1)) || (sameICFile > 1)) || (fileIn > 1)) || (onlyP > 1)) || (filePart > 1)) || (info > 1)) || (reductionAlgorithm > 1))) {
			String msg = duplicateParameter.toString();
			int _length = msg.length();
			int _minus = (_length - 1);
			msg = msg.substring(1, _minus);
			int _size_1 = duplicateParameter.size();
			boolean _equals = (_size_1 == 1);
			if (_equals) {
				msg = ("Duplicate parameter " + msg);
			} else {
				msg = ("Duplicate parameters " + msg);
			}
			this.error(msg, 
					ChemicalReactionNetworkPackage.eINSTANCE.getReduction_OptionalParametersFormatted());
		}
	}

	/**
	 * @Check
	 * def checkUniqueIC(ICList icList) {
	 * var pos=0;
	 * var i=0;
	 * //var duplicateIC = new HashSet<String>(icList.allIC.size);
	 * var foundIC = new HashSet<String>(icList.allIC.size);
	 * var dupIC = new ArrayList<InitialConcentration>();
	 * for(ic : icList.allIC){
	 * i++;
	 * var name = ic.name.name;
	 * if(foundIC.contains(name)){
	 * pos=i;//String.valueOf(i);
	 * //duplicateIC.add(name)
	 * dupIC.add(ic)
	 * }
	 * else{
	 * foundIC.add(name);
	 * }
	 * }
	 * if(dupIC.size>0){
	 * //var msg = duplicateIC.toString
	 * //msg = msg.substring(1,msg.length-1)
	 * //msg = 'Duplicate initial concentration for the species '+msg
	 * //error(msg,ChemicalReactionNetworkPackage.Literals.IC_LIST__ALL_IC,pos)
	 * for(ic2 : dupIC){
	 * //error(msg,ic2.name,ChemicalReactionNetworkPackage.Literals.PARAMETER_OR_SPECIES__NAME)
	 * var msg = 'Duplicate initial concentration for the species ' + ic2.name.name
	 * error(msg,ic2,ChemicalReactionNetworkPackage.Literals.INITIAL_CONCENTRATION__NAME)
	 * //ChemicalReactionNetworkPackage.Literals.INI
	 * }
	 * }
	 * }
	 */
	@Check
	public void checkModel(final ModelDefinition model) {
		int i = (-1);
		//int nICLists = 0;
		int nViewsLists = 0;
		ArrayList<ViewsList> viewsLists = new ArrayList<ViewsList>();
		ArrayList<ICList> icLists = new ArrayList<ICList>();
		int nODEsList = 0;
		int nALGConstraints = 0;
		int nReactionssList = 0;
		int nonMassActionReactions = 0;
		int nonElementaryReactions = 0;
		int nInitPartition = 0;
		int nSymbPars = 0;
		LinkedHashSet<String> undefinedSpecies = new LinkedHashSet<String>();
		Import importCommand = ((Import) null);
		LinkedHashSet<Species> speciesWithoutDynamics = new LinkedHashSet<Species>();
		LinkedHashSet<Node> nodesWithoutDynamics = new LinkedHashSet<>();
		LinkedHashSet<MVNode> mvNodesWithoutDynamics = new LinkedHashSet<>();
		boolean importedModel = false;
		boolean mrmc = false;
		boolean isBN=false;
		boolean isMV=false;
		EList<EObject> _elements = model.getElements();
		for (final EObject elem : _elements) {
			{
				i++;
				if ((elem instanceof ViewsList)) {
					nViewsLists++;
					viewsLists.add(((ViewsList)elem));
				} else {
					if ((elem instanceof Import)) {
						importCommand = ((Import) elem);
						importedModel = true;
						if ((importCommand instanceof importMRMC)) {
							mrmc = true;
						}
					} else {
						if ((elem instanceof ICList)) {
							//nICLists++;
							icLists.add(((ICList)elem));
						} else {
							if ((elem instanceof SymbolicParametersList)) {
								nSymbPars = ((SymbolicParametersList)elem).getSymbolicParameters().size();
							} else {
								if ((elem instanceof NodeDefinitions)) {
									isBN=true;
									EList<NodeDefinition> _nodeDefinitions = ((NodeDefinitions)elem).getNodeDefinitions();
									//									for (final NodeDefinition nodeDefinition : _nodeDefinitions) {
									//										String _name = nodeDefinition.getName().getName();
									//										boolean _tripleEquals = (_name == null);
									//										if (_tripleEquals) {
									//											this.addUndefinedNode(nodeDefinition, undefinedSpecies);
									//										}
									//									}

									///
									//ODEsList odes = ((ODEsList) elem);
									EList<Node> _allSpecies_1 = (((NodeDeclarations[])Conversions.unwrapArray((Iterables.<NodeDeclarations>filter(model.getElements(), NodeDeclarations.class)), NodeDeclarations.class))[0]).getAllNodes();
									LinkedHashSet<Node> _linkedHashSet_1 = new LinkedHashSet<>(_allSpecies_1);
									nodesWithoutDynamics = _linkedHashSet_1;
									int _size = _nodeDefinitions.size();
									final LinkedHashSet<Node> nodesWithDynamics = new LinkedHashSet<>(_size);
									ArrayList<NodeDefinition> dupUpdateFunc = new ArrayList<>();
									for (final NodeDefinition updateFunc : _nodeDefinitions) {
										{
											nodesWithoutDynamics.remove(updateFunc.getName());
											boolean _contains = nodesWithDynamics.contains(updateFunc.getName());
											if (_contains) {
												dupUpdateFunc.add(updateFunc);
											} else {
												nodesWithDynamics.add(updateFunc.getName());
											}
											String _name_1 = updateFunc.getName().getName();
											boolean _tripleEquals_1 = (_name_1 == null);
											if (_tripleEquals_1) {
												this.addUndefinedNode(updateFunc, undefinedSpecies);
											}
										}
									}
									int _size_1 = dupUpdateFunc.size();
									boolean _greaterThan = (_size_1 > 0);
									if (_greaterThan) {
										for (final NodeDefinition updFunc : dupUpdateFunc) {
											{
												String _name_1 = updFunc.getName().getName();
												String msg = ("Duplicate Update Function for the species " + _name_1);
												this.error(msg, updFunc, 
														ChemicalReactionNetworkPackage.eINSTANCE.getNodeDefinition_Name()/*, ChemicalReactionNetworkValidator.DUPLICATE_ODE*/);
											}
										}
									}
								} 
								//////
								else if ((elem instanceof MVNodeDefinitions)) {
									isMV=true;
									EList<MVNodeDefinition> _nodeDefinitions = ((MVNodeDefinitions)elem).getMvNodeDefinitions();
									EList<MVNode> _allSpecies_1 = (((MVNodeDeclarations[])Conversions.unwrapArray((Iterables.<MVNodeDeclarations>filter(model.getElements(), MVNodeDeclarations.class)), MVNodeDeclarations.class))[0]).getAllMVNodes();
									LinkedHashSet<MVNode> _linkedHashSet_1 = new LinkedHashSet<>(_allSpecies_1);
									mvNodesWithoutDynamics = _linkedHashSet_1;
									int _size = _nodeDefinitions.size();
									final LinkedHashSet<MVNode> mvNodesWithDynamics = new LinkedHashSet<>(_size);
									ArrayList<MVNodeDefinition> dupUpdateFunc = new ArrayList<>();
									for (final MVNodeDefinition updateFunc : _nodeDefinitions) {
										{
											mvNodesWithoutDynamics.remove(updateFunc.getName());
											if (mvNodesWithDynamics.contains(updateFunc.getName())) {
												dupUpdateFunc.add(updateFunc);
											} else {
												mvNodesWithDynamics.add(updateFunc.getName());
											}
											//String _name_1 = updateFunc.getName().getName();
											//boolean _tripleEquals_1 = (_name_1 == null);
											if (updateFunc.getName().getName()==null) {
												this.addUndefinedMVNode(updateFunc, undefinedSpecies);
											}
											else {
												//The node exists. If this is a simple case function, I check that the update function contains only correct values
												MVNode sp = updateFunc.getName();
												int max=Math.max(1,sp.getMax());
												if(updateFunc.getUpdateFunction() instanceof MVUpdateFunctions) {
													MVUpdateFunctions caseFunction=(MVUpdateFunctions)updateFunc.getUpdateFunction();
												//for(MVUpdateFunctions updateFunc_addend : updateFunc.getUpdateFunction().getCaseFunction()) {
													int otherwise=0;
													HashSet<Integer> values=new HashSet<>(caseFunction.getCasesMV().size());
													for(caseMV cur_case : caseFunction.getCasesMV()) {
														int cur=cur_case.getVal();
														if(cur>max) {
															this.error("Wrong value "+cur+" for species "+sp.getName(), cur_case, //updateFunc, 
																	ChemicalReactionNetworkPackage.eINSTANCE.getcaseMV_Val());
															//ChemicalReactionNetworkPackage.eINSTANCE.getMVNodeDefinition_Name()/*, ChemicalReactionNetworkValidator.DUPLICATE_ODE*/);
														}
														else {
															values.add(cur);
														}
														if(cur_case.getACaseMV()==null) {
															otherwise++;
														}
													}
													if(otherwise > 1 ||(otherwise == 0 && values.size()==max+1)) {
														this.error("The'otherwise' case should be once (or implicitly by providing 1 case less). It is used "+otherwise+" times for "+sp.getName()+".", updateFunc, 
																ChemicalReactionNetworkPackage.eINSTANCE.getMVNodeDefinition_Name()/*, ChemicalReactionNetworkValidator.DUPLICATE_ODE*/);
													}
													if(otherwise == 0 && values.size()<max) {
														this.error("The otherwise case be omitted (given implicitly) only if all other cases are specified. Problem for "+sp.getName()+".", updateFunc, 
																ChemicalReactionNetworkPackage.eINSTANCE.getMVNodeDefinition_Name()/*, ChemicalReactionNetworkValidator.DUPLICATE_ODE*/);
													}
													//													if(otherwise == 1 && values.size()<max+1) {
													//														this.error("Missing cases for "+sp.getName()+" please consider all from 0 to "+max, updateFunc, 
													//																ChemicalReactionNetworkPackage.eINSTANCE.getMVNodeDefinition_Name()/*, ChemicalReactionNetworkValidator.DUPLICATE_ODE*/);
													//													}


												}

											}
										}
									}
									int _size_1 = dupUpdateFunc.size();
									boolean _greaterThan = (_size_1 > 0);
									if (_greaterThan) {
										for (final MVNodeDefinition updFunc : dupUpdateFunc) {
											{
												String _name_1 = updFunc.getName().getName();
												String msg = ("Duplicate Update Function for the species " + _name_1);
												this.error(msg, updFunc, 
														ChemicalReactionNetworkPackage.eINSTANCE.getMVNodeDefinition_Name()/*, ChemicalReactionNetworkValidator.DUPLICATE_ODE*/);
											}
										}
									}
									//////
								}

								else {
									if ((elem instanceof ReactionsList)) {
										int _nReactionssList = nReactionssList;
										nReactionssList = (_nReactionssList + 1);
										ReactionsList reactions = ((ReactionsList) elem);
										EList<Species> _allSpecies = (((ICList[])Conversions.unwrapArray((Iterables.<ICList>filter(model.getElements(), ICList.class)), ICList.class))[0]).getAllSpecies();
										LinkedHashSet<Species> _linkedHashSet = new LinkedHashSet<Species>(_allSpecies);
										speciesWithoutDynamics = _linkedHashSet;
										EList<Reaction> _allReactions = reactions.getAllReactions();
										for (final Reaction reaction : _allReactions) {
											{
												RateOfReaction _rate = reaction.getRate();
												boolean _not = (!(_rate instanceof MassActionRate));
												if (_not) {
													nonMassActionReactions++;
													nonElementaryReactions++;
												} else {
													int _arity = this.getArity(reaction.getReagents());
													boolean _greaterThan = (_arity > 2);
													if (_greaterThan) {
														nonElementaryReactions++;
													}
												}
												Composite comp = reaction.getReagents();
												EList<SpeciesWithMultiplicity> _speciesOfComposite = comp.getSpeciesOfComposite();
												for (final SpeciesWithMultiplicity speciesAndMult : _speciesOfComposite) {
													{
														speciesWithoutDynamics.remove(speciesAndMult.getSpecies());
														String _name_1 = speciesAndMult.getSpecies().getName();
														boolean _tripleEquals_1 = (_name_1 == null);
														if (_tripleEquals_1) {
															this.addUndefinedSpecies(speciesAndMult, undefinedSpecies);
														}
													}
												}
												comp = reaction.getProducts();
												EList<SpeciesWithMultiplicity> _speciesOfComposite_1 = comp.getSpeciesOfComposite();
												for (final SpeciesWithMultiplicity speciesAndMult_1 : _speciesOfComposite_1) {
													{
														speciesWithoutDynamics.remove(speciesAndMult_1.getSpecies());
														String _name_1 = speciesAndMult_1.getSpecies().getName();
														boolean _tripleEquals_1 = (_name_1 == null);
														if (_tripleEquals_1) {
															this.addUndefinedSpecies(speciesAndMult_1, undefinedSpecies);
														}
													}
												}
											}
										}
									} else {
										if ((elem instanceof InitPartition)) {
											int _nInitPartition = nInitPartition;
											nInitPartition = (_nInitPartition + 1);
											HashSet<SpeciesOrNode> speciesInPartition = new HashSet<SpeciesOrNode>();
											EList<Block> _allBlocks = ((InitPartition)elem).getAllBlocks();
											for (final Block block : _allBlocks) {
												{
													int pos = 0;
													EList<SpeciesOrNode> _allSpecies_1 = block.getAllSpecies();
													for (final SpeciesOrNode species : _allSpecies_1) {
														{
															boolean _contains = speciesInPartition.contains(species);
															if (_contains) {
																String _name_1 = species.getName();
																String _plus = ("Duplicate " + _name_1);
																String _plus_1 = (_plus + " entry in the partition");
																this.error(_plus_1, block, 
																		ChemicalReactionNetworkPackage.eINSTANCE.getBlock_AllSpecies(), pos);
															} else {
																speciesInPartition.add(species);
															}
															pos++;
														}
													}
												}
											}
										} else {
											if ((elem instanceof AlgebraicList)) {
												EList<ALG> _algs = ((AlgebraicList)elem).getAlgs();
												boolean _tripleNotEquals = (_algs != null);
												if (_tripleNotEquals) {
													nALGConstraints = ((AlgebraicList)elem).getAlgs().size();
												}
											} else {
												if ((elem instanceof ODEsList)) {
													int _nODEsList = nODEsList;
													nODEsList = (_nODEsList + 1);
													ODEsList odes = ((ODEsList) elem);
													EList<Species> _allSpecies_1 = (((ICList[])Conversions.unwrapArray((Iterables.<ICList>filter(model.getElements(), ICList.class)), ICList.class))[0]).getAllSpecies();
													LinkedHashSet<Species> _linkedHashSet_1 = new LinkedHashSet<Species>(_allSpecies_1);
													speciesWithoutDynamics = _linkedHashSet_1;
													int _size = odes.getOdes().size();
													final LinkedHashSet<Species> speciesWithDynamics = new LinkedHashSet<Species>(_size);
													ArrayList<ODE> dupODE = new ArrayList<ODE>();
													EList<ODE> _odes = odes.getOdes();
													for (final ODE ode : _odes) {
														{
															speciesWithoutDynamics.remove(ode.getName());
															boolean _contains = speciesWithDynamics.contains(ode.getName());
															if (_contains) {
																dupODE.add(ode);
															} else {
																speciesWithDynamics.add(ode.getName());
															}
															String _name_1 = ode.getName().getName();
															boolean _tripleEquals_1 = (_name_1 == null);
															if (_tripleEquals_1) {
																this.addUndefinedSpecies(ode, undefinedSpecies);
															}
														}
													}
													int _size_1 = dupODE.size();
													boolean _greaterThan = (_size_1 > 0);
													if (_greaterThan) {
														for (final ODE ode_1 : dupODE) {
															{
																String _name_1 = ode_1.getName().getName();
																String msg = ("Duplicate ODE for the species " + _name_1);
																this.error(msg, ode_1, 
																		ChemicalReactionNetworkPackage.eINSTANCE.getODE_Name(), ChemicalReactionNetworkValidator.DUPLICATE_ODE);
															}
														}
													}
												} else {
													if ((elem instanceof simulateDAE)) {
														if (((nALGConstraints < 1) && (importedModel == false))) {
															String msg = "There are no algebraic constraints. You can replace simulateDAE with simulateODE";
															int moreThanSize = 1;
															EList<ParametersSimulateODE> _params = ((simulateDAE)elem).getParams();
															boolean _tripleNotEquals_1 = (_params != null);
															if (_tripleNotEquals_1) {
																int _size_2 = ((simulateDAE)elem).getParams().size();
																int _plus = (_size_2 + 1);
																moreThanSize = _plus;
															}
															this.warning(msg, elem, ChemicalReactionNetworkPackage.eINSTANCE.getsimulateDAE_Params(), moreThanSize);
														}
													} else {
														if ((elem instanceof simulateODE)) {
															if ((nALGConstraints > 0)) {
																String msg_1 = "Command simulateODE cannot be used on models with algebraic constraints. Use simulateDAE.";
																int moreThanSize_1 = 1;
																EList<ParametersSimulateODE> _params_1 = ((simulateODE)elem).getParams();
																boolean _tripleNotEquals_2 = (_params_1 != null);
																if (_tripleNotEquals_2) {
																	int _size_3 = ((simulateODE)elem).getParams().size();
																	int _plus_1 = (_size_3 + 1);
																	moreThanSize_1 = _plus_1;
																}
																this.error(msg_1, elem, ChemicalReactionNetworkPackage.eINSTANCE.getsimulateODE_Params(), moreThanSize_1, ChemicalReactionNetworkValidator.SIMULATEODE_ALGEBRAIC);
															}
														} else {
															if ((elem instanceof Reduction)) {
																if ((nInitPartition == 0)) {
																	this.checkPrep(((Reduction)elem).getOptionalParametersFormatted().getOptionalParameters(), i, model, importedModel);
																}
																if ((elem instanceof reduceUncertainFE)) {
																	if ((!mrmc)) {
																		String msg_2 = "FCE is supported only for models imported from the format MRMC";
																		this.error(msg_2, model, ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i);
																	}
																}
																if ((elem instanceof MassActionReduction)) {
																	String[] msg_3 = MyValidatorUtil.checkMassActionReduction(((MassActionReduction)elem), nODEsList, nonMassActionReactions, nonElementaryReactions, nSymbPars, importCommand, nALGConstraints);
																	this.handleMSG(msg_3, model, i);
																} else {
																	if ((nALGConstraints > 0)) {
																		this.allowOnlyReduceBDE(((Reduction)elem), model, i);
																	}
																}
																if(elem instanceof reduceFME && !isMV) {
																	String msg_2 = "FME is supported only for multivalued networks";
																	this.error(msg_2, model, ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i);
																}
																else if((elem instanceof reduceFBE /*|| elem instanceof reduceBBE*/) && !isBN) {
																	String msg_2 = "FBE are supported only for Boolean networks. Use FME for Multivalue Boolean networks";
																	this.error(msg_2, model, ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i);
																} 
															} else {
																if ((elem instanceof UpdateStatusCommand)) {
																	Reduction _reduction = ((UpdateStatusCommand)elem).getReduction();
																	if ((nInitPartition == 0)) {
																		this.checkPrep(_reduction.getOptionalParametersFormatted().getOptionalParameters(), i, model, importedModel);
																	}
																	if ((_reduction instanceof MassActionReduction)) {
																		//Reduction _reduction_1 = ((UpdateStatusReduction)elem).getReduction();
																		MassActionReduction red = ((MassActionReduction) _reduction);
																		String[] msg_4 = MyValidatorUtil.checkMassActionReduction(red, nODEsList, nonMassActionReactions, nonElementaryReactions, nSymbPars, importCommand, nALGConstraints);
																		this.handleMSG(msg_4, model, i);
																	} else {
																		if ((nALGConstraints > 0)) {
																			this.allowOnlyReduceBDE(_reduction, model, i);
																		}
																	}
																} else {
																	//																if ((elem instanceof UpdateStatusReduction)) {
																	//																	if ((nInitPartition == 0)) {
																	//																		this.checkPrep(((UpdateStatusReduction)elem).getReduction().getOptionalParametersFormatted().getOptionalParameters(), i, model, importedModel);
																	//																	}
																	//																	Reduction _reduction = ((UpdateStatusReduction)elem).getReduction();
																	//																	if ((_reduction instanceof MassActionReduction)) {
																	//																		Reduction _reduction_1 = ((UpdateStatusReduction)elem).getReduction();
																	//																		MassActionReduction red = ((MassActionReduction) _reduction_1);
																	//																		String[] msg_4 = MyValidatorUtil.checkMassActionReduction(red, nODEsList, nonMassActionReactions, nonElementaryReactions, nSymbPars, importCommand, nALGConstraints);
																	//																		this.handleMSG(msg_4, model, i);
																	//																	} else {
																	//																		this.allowOnlyReduceBDE(((UpdateStatusReduction)elem).getReduction(), model, i);
																	//																	}
																	//																} else {
																	if ((elem instanceof Analysis)) {
																		if ((nSymbPars > 0)) {
																			String msg_5 = "Models with symbolic parameters are not amenable to analysis.";
																			this.error(msg_5, model, 
																					ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i, ChemicalReactionNetworkValidator.ANALYSIS_SYMBOLIC);
																		}
																	} else {
																		if ((elem instanceof Export)) {
																			if ((nSymbPars > 0)) {
																				String msg_6 = "Models with symbolic parameters cannot be exported.";
																				this.error(msg_6, elem, 
																						ChemicalReactionNetworkPackage.eINSTANCE.getExport_Params());
																			}
																			if (((elem instanceof exportBNG) || (elem instanceof exportLBS))) {
																				if (((nODEsList > 0) || (nonMassActionReactions > 0))) {
																					String msg_7 = "Only mass-action reaction networks can be exported in this format.";
																					this.error(msg_7, elem, 
																							ChemicalReactionNetworkPackage.eINSTANCE.getExport_Params());
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((nViewsLists > 1)) {
			String msg = "One list of views only should be given";
			this.error(msg, 
					ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Name());
		}
		int _size = undefinedSpecies.size();
		boolean _notEquals = (_size != 0);
		if (_notEquals) {
			String msg_1 = "Couldn\'t resolve references to species:";
			int _size_1 = undefinedSpecies.size();
			boolean _equals = (_size_1 == 1);
			if (_equals) {
				msg_1 = "Couldn\'t resolve reference to species:";
			}
			List<String> undefinedSpeciesList = IterableExtensions.<String>toList(undefinedSpecies);
			Collections.<String>sort(undefinedSpeciesList);
			for (final String s : undefinedSpeciesList) {
				msg_1 = ((msg_1 + " ") + s);
			}
			this.error(msg_1, 
					ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Name(), ChemicalReactionNetworkValidator.UNDEFINED_SPECIES);
		}
		int _size_2 = speciesWithoutDynamics.size();
		boolean _notEquals_1 = (_size_2 != 0);
		if (_notEquals_1) {
			for (final Species s_1 : speciesWithoutDynamics) {
				if ((nReactionssList > 0)) {
					String _name = s_1.getName();
					String msg_2 = ("No dynamics have been provided for: " + _name);
					this.warning(msg_2, s_1, 
							ChemicalReactionNetworkPackage.eINSTANCE.getSpeciesOrNode_Name());
				} else {
					if ((nODEsList > 0)) {
						String _name_1 = s_1.getName();
						String msg_3 = ("Missing drift of species " + _name_1);
						this.error(msg_3, s_1, 
								ChemicalReactionNetworkPackage.eINSTANCE.getSpeciesOrNode_Name(), ChemicalReactionNetworkValidator.MISSING_DRIFT);
					}
				}
			}
			if ((nODEsList > 0)) {
				String msg_4 = "Missing drifts of species:";
				int _size_3 = speciesWithoutDynamics.size();
				boolean _equals_1 = (_size_3 == 1);
				if (_equals_1) {
					msg_4 = "Missing drift of species:";
				}
				for (final Species s_2 : speciesWithoutDynamics) {
					String _name_2 = s_2.getName();
					String _plus = ((msg_4 + " ") + _name_2);
					msg_4 = _plus;
				}
				this.error(msg_4, 
						ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Name(), ChemicalReactionNetworkValidator.MISSING_DRIFTS);
			}
		}

		if(nodesWithoutDynamics.size()>0) {
			for(Node node : nodesWithoutDynamics) {
				String _name_1 = node.getName();
				String msg_3 = ("Missing update function of species " + _name_1);
				this.error(msg_3, node, 
						ChemicalReactionNetworkPackage.eINSTANCE.getSpeciesOrNode_Name()/*, ChemicalReactionNetworkValidator.MISSING_DRIFT*/);
			}
		}
		if(mvNodesWithoutDynamics.size()>0) {
			for(MVNode node : mvNodesWithoutDynamics) {
				String _name_1 = node.getName();
				String msg_3 = ("Missing update function of species " + _name_1);
				this.error(msg_3, node, 
						ChemicalReactionNetworkPackage.eINSTANCE.getSpeciesOrNode_Name()/*, ChemicalReactionNetworkValidator.MISSING_DRIFT*/);
			}
		}
	}


	protected void allowOnlyReduceBDE(final Reduction elem, final ModelDefinition model, final int i) {
		if ((!(elem instanceof reduceBDE))) {
			String name = elem.getClass().getName();
			int _lastIndexOf = name.lastIndexOf(".");
			int _plus = (_lastIndexOf + 1);
			name = name.substring(_plus, name.lastIndexOf("Impl"));
			String msg = (("Cannot apply " + name) + " to models with algebraic constraints");
			this.error(msg, model, ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i);
		}
	}

	protected void handleMSG(final String[] msg, final ModelDefinition model, final int i) {
		if ((msg != null)) {
			if (((msg[1] != null) && (msg[1]).equals("WARNING"))) {
				this.warning(msg[0], model, 
						ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i);
			} else {
				this.error(msg[0], model, 
						ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i, msg[1]);
			}
		}
	}

	public void checkPrep(final EList<OptionalParametersReductions> list, final int i, final ModelDefinition model, final boolean importedModel) {
		for (final OptionalParametersReductions par : list) {
			if ((par instanceof Prep)) {
				boolean _equals = ((Prep)par).getPrep().equals("USER");
				if (_equals) {
					if ((!importedModel)) {
						String msg = "No partition has been provided";
						this.error(msg, model, 
								ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i);
					} else {
						String msg_1 = "Problems might arise in case no partition has been defined in the imported model";
						this.warning(msg_1, model, 
								ChemicalReactionNetworkPackage.eINSTANCE.getModelDefinition_Elements(), i);
					}
				}
			}
		}
	}

	/**
	 * def updateUndefinedSpecies(Expression expression, LinkedHashSet<String> undefinedSpeciesNames) {
	 * MyParserUtil.visitExpr(expression,undefinedSpeciesNames)
	 * }
	 */
	public boolean addUndefinedNode(final NodeDefinition nodeDef, final LinkedHashSet<String> undefinedSpecies) {
		boolean _xblockexpression = false;
		{
			ICompositeNode importNode = NodeModelUtils.findActualNodeFor(nodeDef);
			int offset = importNode.getOffset();
			String text = importNode.getText();
			int _totalOffset = importNode.getTotalOffset();
			int _minus = (offset - _totalOffset);
			text = text.substring(_minus);
			int endPos = text.indexOf("=");
			if ((endPos != (-1))) {
				text = text.substring(0, endPos);
			} else {
				endPos = text.indexOf(":");
				if ((endPos != (-1))) {
					text = text.substring(0, endPos);
				}
			}
			_xblockexpression = undefinedSpecies.add(text.trim());
		}
		return _xblockexpression;
	}
	public boolean addUndefinedMVNode(final MVNodeDefinition nodeDef, final LinkedHashSet<String> undefinedSpecies) {
		boolean _xblockexpression = false;
		{
			ICompositeNode importNode = NodeModelUtils.findActualNodeFor(nodeDef);
			int offset = importNode.getOffset();
			String text = importNode.getText();
			int _totalOffset = importNode.getTotalOffset();
			int _minus = (offset - _totalOffset);
			text = text.substring(_minus);
			int endPos = text.indexOf("=");
			if ((endPos != (-1))) {
				text = text.substring(0, endPos);
			} else {
				endPos = text.indexOf(":");
				if ((endPos != (-1))) {
					text = text.substring(0, endPos);
				}
			}
			_xblockexpression = undefinedSpecies.add(text.trim());
		}
		return _xblockexpression;
	}

	public boolean addUndefinedSpecies(final SpeciesWithMultiplicity speciesAndMult, final LinkedHashSet<String> undefinedSpecies) {
		boolean _xblockexpression = false;
		{
			ICompositeNode importNode = NodeModelUtils.findActualNodeFor(speciesAndMult);
			int offset = importNode.getOffset();
			String text = importNode.getText();
			int _totalOffset = importNode.getTotalOffset();
			int _minus = (offset - _totalOffset);
			text = text.substring(_minus);
			int starPos = text.indexOf("*");
			if ((starPos != (-1))) {
				text = text.substring((starPos + 1));
			}
			_xblockexpression = undefinedSpecies.add(text.trim());
		}
		return _xblockexpression;
	}

	public boolean addUndefinedSpecies(final ODE ode, final LinkedHashSet<String> undefinedSpecies) {
		boolean _xblockexpression = false;
		{
			ICompositeNode importNode = NodeModelUtils.findActualNodeFor(ode);
			int offset = importNode.getOffset();
			String text = importNode.getText();
			int _totalOffset = importNode.getTotalOffset();
			int _minus = (offset - _totalOffset);
			text = text.substring(_minus);
			int eqPos = text.indexOf("=");
			if ((eqPos != (-1))) {
				text = text.substring(0, eqPos);
			}
			int dPos = text.indexOf("d(");
			if ((dPos != (-1))) {
				text = text.substring((dPos + 2));
			}
			int closedPar = text.indexOf(")");
			if ((closedPar != (-1))) {
				text = text.substring(0, closedPar);
			}
			_xblockexpression = undefinedSpecies.add(text.trim());
		}
		return _xblockexpression;
	}

	public int getArity(final Composite composite) {
		int _xblockexpression = (int) 0;
		{
			int arity = 0;
			EList<SpeciesWithMultiplicity> _speciesOfComposite = composite.getSpeciesOfComposite();
			for (final SpeciesWithMultiplicity speciesWithMult : _speciesOfComposite) {
				int _multiplicity = speciesWithMult.getMultiplicity();
				boolean _equals = (_multiplicity == 0);
				if (_equals) {
					int _arity = arity;
					arity = (_arity + 1);
				} else {
					int _arity_1 = arity;
					int _multiplicity_1 = speciesWithMult.getMultiplicity();
					arity = (_arity_1 + _multiplicity_1);
				}
			}
			_xblockexpression = arity;
		}
		return _xblockexpression;
	}

	@Check
	public void checkUniqueParametersOfSimulateCTMC(final simulateCTMC sim) {
		int nFileIn = 0;
		int nSteps = 0;
		int nStepSize = 0;
		int nVisualizePlot = 0;
		int nCSVFile = 0;
		int nMethod = 0;
		int nRepeats = 0;
		int nDefaultIC = 0;
		int pos = 0;
		int pos2 = 0;
		int i = (-1);
		int _size = sim.getParams().size();
		HashSet<String> duplicateParameter = new HashSet<String>(_size);
		EList<ParametersSimulateCTMC> _params = sim.getParams();
		for (final ParametersSimulateCTMC par : _params) {
			{
				i++;
				if ((par instanceof Steps)) {
					nSteps++;
					pos2 = i;
					if ((nSteps > 1)) {
						pos = i;
						duplicateParameter.add("steps");
					}
				}
				if ((par instanceof StepSize)) {
					nStepSize++;
					pos2 = i;
					if ((nStepSize > 1)) {
						pos = i;
						duplicateParameter.add("stepSize");
					}
				} else {
					if ((par instanceof VisualizePlot)) {
						nVisualizePlot++;
						if ((nVisualizePlot > 1)) {
							pos = i;
							duplicateParameter.add("visualizePlot");
						}
					} else {
						if ((par instanceof DefaultIC)) {
							nDefaultIC++;
							if ((nDefaultIC > 1)) {
								pos = i;
								duplicateParameter.add("nDefaultIC");
							}
						} else {
							if ((par instanceof CSVFile)) {
								nCSVFile++;
								if ((nCSVFile > 1)) {
									pos = i;
									duplicateParameter.add("csvFile");
								}
							} else {
								if ((par instanceof Method)) {
									nMethod++;
									if ((nMethod > 1)) {
										pos = i;
										duplicateParameter.add("method");
									}
								} else {
									if ((par instanceof Repeats)) {
										nRepeats++;
										if ((nRepeats > 1)) {
											pos = i;
											duplicateParameter.add("repeats");
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (((((((((nFileIn > 1) || (nSteps > 1)) || (nVisualizePlot > 1)) || (nCSVFile > 1)) || (nMethod > 1)) || (nRepeats > 1)) || (nDefaultIC > 1)) || (nStepSize > 1))) {
			String msg = duplicateParameter.toString();
			int _length = msg.length();
			int _minus = (_length - 1);
			msg = msg.substring(1, _minus);
			int _size_1 = duplicateParameter.size();
			boolean _equals = (_size_1 == 1);
			if (_equals) {
				msg = ("Duplicate parameter " + msg);
			} else {
				msg = ("Duplicate parameters " + msg);
			}
			this.error(msg, 
					ChemicalReactionNetworkPackage.eINSTANCE.getsimulateCTMC_Params(), pos);
		}
		if (((nSteps > 0) && (nStepSize > 0))) {
			String msg_1 = "Specify either the number of steps or the step size";
			this.error(msg_1, 
					ChemicalReactionNetworkPackage.eINSTANCE.getsimulateCTMC_Params(), pos2);
		}
	}

	@Check
	public void checkUniqueParametersOfSimulateODE(final simulateODE sim) {
		int nFileIn = 0;
		int nSteps = 0;
		int nStepSize = 0;
		int nVisualizePlot = 0;
		int nCSVFile = 0;
		int nMinStep = 0;
		int nMaxStep = 0;
		int nAbsTol = 0;
		int nRelsTol = 0;
		int nSolverLibrary = 0;
		int nDefaultIC = 0;
		int nComputeJacobian = 0;
		int pos2 = 0;
		int pos = 0;
		int i = (-1);
		int _size = sim.getParams().size();
		HashSet<String> duplicateParameter = new HashSet<String>(_size);
		EList<ParametersSimulateODE> _params = sim.getParams();
		for (final ParametersSimulateODE par : _params) {
			{
				i++;
				if ((par instanceof Steps)) {
					nSteps++;
					pos2 = i;
					if ((nSteps > 1)) {
						pos = i;
						duplicateParameter.add("steps");
					}
				}
				if ((par instanceof StepSize)) {
					nStepSize++;
					pos2 = i;
					if ((nStepSize > 1)) {
						pos = i;
						duplicateParameter.add("stepSize");
					}
				} else {
					if ((par instanceof VisualizePlot)) {
						nVisualizePlot++;
						if ((nVisualizePlot > 1)) {
							pos = i;
							duplicateParameter.add("visualizePlot");
						}
					} else {
						if ((par instanceof DefaultIC)) {
							nDefaultIC++;
							if ((nDefaultIC > 1)) {
								pos = i;
								duplicateParameter.add("defaultIC");
							}
						} else {
							if ((par instanceof ComputeJacobian)) {
								nComputeJacobian++;
								if ((nComputeJacobian > 1)) {
									pos = i;
									duplicateParameter.add("computeJacobian");
								}
							} else {
								if ((par instanceof CSVFile)) {
									nCSVFile++;
									if ((nCSVFile > 1)) {
										pos = i;
										duplicateParameter.add("csvFile");
									}
								} else {
									if ((par instanceof MinStep)) {
										nMinStep++;
										if ((nMinStep > 1)) {
											pos = i;
											duplicateParameter.add("minStep");
										}
									} else {
										if ((par instanceof MaxStep)) {
											nMaxStep++;
											if ((nMaxStep > 1)) {
												pos = i;
												duplicateParameter.add("maxStep");
											}
										} else {
											if ((par instanceof AbsTol)) {
												nAbsTol++;
												if ((nAbsTol > 1)) {
													pos = i;
													duplicateParameter.add("absTol");
												}
											} else {
												if ((par instanceof RelsTol)) {
													nRelsTol++;
													if ((nRelsTol > 1)) {
														pos = i;
														duplicateParameter.add("relsTol");
													}
												} else {
													if ((par instanceof SolverLibrary)) {
														nSolverLibrary++;
														if ((nSolverLibrary > 1)) {
															pos = i;
															duplicateParameter.add("library");
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((((((((((((nFileIn > 1) || (nSteps > 1)) || (nVisualizePlot > 1)) || (nCSVFile > 1)) || (nMinStep > 1)) || (nMaxStep > 1)) || (nAbsTol > 1)) || (nRelsTol > 1)) || (nDefaultIC > 1)) || (nComputeJacobian > 1)) || (nStepSize > 1))) {
			String msg = duplicateParameter.toString();
			int _length = msg.length();
			int _minus = (_length - 1);
			msg = msg.substring(1, _minus);
			int _size_1 = duplicateParameter.size();
			boolean _equals = (_size_1 == 1);
			if (_equals) {
				msg = ("Duplicate parameter " + msg);
			} else {
				msg = ("Duplicate parameters " + msg);
			}
			this.error(msg, 
					ChemicalReactionNetworkPackage.eINSTANCE.getsimulateODE_Params(), pos);
		}
		if (((nSteps > 0) && (nStepSize > 0))) {
			String msg_1 = "Specify either the number of steps or the step size";
			this.error(msg_1, sim, 
					ChemicalReactionNetworkPackage.eINSTANCE.getsimulateODE_Params(), pos2);
		}
	}

	@Check
	public void checkParametersOfSimulateDAE(final simulateDAE sim) {
		int nFileIn = 0;
		int nSteps = 0;
		int nStepSize = 0;
		int nVisualizePlot = 0;
		int nCSVFile = 0;
		int nMinStep = 0;
		int nMaxStep = 0;
		int nAbsTol = 0;
		int nRelsTol = 0;
		int nSolverLibrary = 0;
		int nDefaultIC = 0;
		int nComputeJacobian = 0;
		int pos2 = 0;
		int pos = 0;
		int i = (-1);
		int _size = sim.getParams().size();
		HashSet<String> duplicateParameter = new HashSet<String>(_size);
		EList<ParametersSimulateODE> _params = sim.getParams();
		for (final ParametersSimulateODE par : _params) {
			{
				i++;
				if ((par instanceof Steps)) {
					nSteps++;
					pos2 = i;
					if ((nSteps > 1)) {
						pos = i;
						duplicateParameter.add("steps");
					}
				}
				if ((par instanceof StepSize)) {
					nStepSize++;
					pos2 = i;
					if ((nStepSize > 1)) {
						pos = i;
						duplicateParameter.add("stepSize");
					}
				} else {
					if ((par instanceof VisualizePlot)) {
						nVisualizePlot++;
						if ((nVisualizePlot > 1)) {
							pos = i;
							duplicateParameter.add("visualizePlot");
						}
					} else {
						if ((par instanceof DefaultIC)) {
							nDefaultIC++;
							if ((nDefaultIC > 1)) {
								pos = i;
								duplicateParameter.add("defaultIC");
							}
						} else {
							if ((par instanceof ComputeJacobian)) {
								nComputeJacobian++;
								if ((nComputeJacobian > 1)) {
									pos = i;
									duplicateParameter.add("computeJacobian");
								}
							} else {
								if ((par instanceof CSVFile)) {
									nCSVFile++;
									if ((nCSVFile > 1)) {
										pos = i;
										duplicateParameter.add("csvFile");
									}
								} else {
									if ((par instanceof MinStep)) {
										nMinStep++;
									} else {
										if ((par instanceof MaxStep)) {
											nMaxStep++;
										} else {
											if ((par instanceof AbsTol)) {
												nAbsTol++;
												if ((nAbsTol > 1)) {
													pos = i;
													duplicateParameter.add("absTol");
												}
											} else {
												if ((par instanceof RelsTol)) {
													nRelsTol++;
													if ((nRelsTol > 1)) {
														pos = i;
														duplicateParameter.add("relsTol");
													}
												} else {
													if ((par instanceof SolverLibrary)) {
														nSolverLibrary++;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((((((((((nFileIn > 1) || (nSteps > 1)) || (nVisualizePlot > 1)) || (nCSVFile > 1)) || (nAbsTol > 1)) || (nRelsTol > 1)) || (nDefaultIC > 1)) || (nComputeJacobian > 1)) || (nStepSize > 1))) {
			String msg = duplicateParameter.toString();
			int _length = msg.length();
			int _minus = (_length - 1);
			msg = msg.substring(1, _minus);
			int _size_1 = duplicateParameter.size();
			boolean _equals = (_size_1 == 1);
			if (_equals) {
				msg = ("Duplicate parameter " + msg);
			} else {
				msg = ("Duplicate parameters " + msg);
			}
			this.error(msg, 
					ChemicalReactionNetworkPackage.eINSTANCE.getsimulateDAE_Params(), pos);
		}
		if ((((nMinStep > 0) || (nMaxStep > 0)) || (nSolverLibrary > 0))) {
			String msg_1 = "maxStep, minStep, and library are not supported for simulateDAE";
			this.error(msg_1, 
					ChemicalReactionNetworkPackage.eINSTANCE.getsimulateDAE_Params(), pos);
		}
		if (((nSteps > 0) && (nStepSize > 0))) {
			String msg_2 = "Specify either the number of steps or the step size";
			this.error(msg_2, sim, 
					ChemicalReactionNetworkPackage.eINSTANCE.getsimulateDAE_Params(), pos2);
		}
	}


}
